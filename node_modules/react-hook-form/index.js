const { useCallback, useMemo, useRef, useState } = require('react');

const DEFAULT_ERROR_MESSAGE = 'Поле заполнено некорректно';

const isEmptyValue = value => value === undefined || value === null || value === '';

const clone = value => {
  if (value === undefined) {
    return {};
  }
  return JSON.parse(JSON.stringify(value));
};

const extractValue = (event, options) => {
  if (options && typeof options.setValueAs === 'function') {
    return options.setValueAs(event.target.value);
  }

  if (options && options.valueAsNumber) {
    const parsed = Number(event.target.value);
    return Number.isNaN(parsed) ? undefined : parsed;
  }

  if (options && options.valueAsDate) {
    const date = new Date(event.target.value);
    return Number.isNaN(date.getTime()) ? undefined : date;
  }

  if (event.target.type === 'checkbox') {
    return event.target.checked;
  }

  return event.target.value;
};

const validateValue = async (value, options) => {
  if (!options) {
    return undefined;
  }

  if (options.required) {
    const message = typeof options.required === 'string' ? options.required : DEFAULT_ERROR_MESSAGE;
    if (isEmptyValue(value)) {
      return { type: 'required', message };
    }
  }

  if (options.minLength && typeof value === 'string' && value.length < Number(options.minLength.value)) {
    return { type: 'minLength', message: options.minLength.message || DEFAULT_ERROR_MESSAGE };
  }

  if (options.maxLength && typeof value === 'string' && value.length > Number(options.maxLength.value)) {
    return { type: 'maxLength', message: options.maxLength.message || DEFAULT_ERROR_MESSAGE };
  }

  if (options.pattern && typeof value === 'string') {
    const pattern = options.pattern.value;
    if (pattern instanceof RegExp && !pattern.test(value)) {
      return { type: 'pattern', message: options.pattern.message || DEFAULT_ERROR_MESSAGE };
    }
  }

  if (options.validate) {
    const validators =
      typeof options.validate === 'function' ? { validate: options.validate } : options.validate;

    for (const [key, validator] of Object.entries(validators)) {
      const result = await validator(value);
      if (result === false) {
        return { type: key, message: DEFAULT_ERROR_MESSAGE };
      }
      if (typeof result === 'string') {
        return { type: key, message: result };
      }
    }
  }

  return undefined;
};

function useForm({ defaultValues } = {}) {
  const valuesRef = useRef(clone(defaultValues || {}));
  const optionsRef = useRef({});
  const touchedRef = useRef({});
  const subscriptionsRef = useRef([]);

  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isValid, setIsValid] = useState(true);
  const [, forceRender] = useState(0);

  const notifySubscribers = useCallback(name => {
    subscriptionsRef.current
      .filter(subscription => !name || subscription.name === name)
      .forEach(subscription => subscription.callback());
  }, []);

  const runValidation = useCallback(async (name, value) => {
    const validationError = await validateValue(value, optionsRef.current[name]);

    setErrors(prevErrors => {
      const nextErrors = { ...prevErrors };
      if (validationError) {
        nextErrors[name] = validationError;
      } else {
        delete nextErrors[name];
      }
      setIsValid(Object.keys(nextErrors).length === 0);
      return nextErrors;
    });
  }, []);

  const register = useCallback(
    (name, options = {}) => {
      optionsRef.current[name] = options;
      const value = valuesRef.current[name];

      const handleBlur = () => {
        touchedRef.current[name] = true;
        notifySubscribers(name);
        runValidation(name, valuesRef.current[name]);
      };

      const handleChange = async event => {
        const nextValue = extractValue(event, optionsRef.current[name]);
        valuesRef.current = {
          ...valuesRef.current,
          [name]: nextValue,
        };

        notifySubscribers(name);

        if (touchedRef.current[name] || optionsRef.current[name]?.shouldUnregister) {
          await runValidation(name, nextValue);
        }
      };

      return {
        name,
        value: value !== undefined ? value : '',
        onChange: handleChange,
        onBlur: handleBlur,
      };
    },
    [notifySubscribers, runValidation]
  );

  const handleSubmit = useCallback(
    onValid => async event => {
      if (event && typeof event.preventDefault === 'function') {
        event.preventDefault();
      }

      setIsSubmitting(true);

      const entries = Object.entries(valuesRef.current);
      const nextErrors = {};

      for (const [name, value] of entries) {
        const result = await validateValue(value, optionsRef.current[name]);
        if (result) {
          nextErrors[name] = result;
        }
      }

      setErrors(nextErrors);
      const hasErrors = Object.keys(nextErrors).length > 0;
      setIsValid(!hasErrors);

      if (!hasErrors) {
        await onValid(clone(valuesRef.current), event);
      }

      setIsSubmitting(false);
    },
    []
  );

  const reset = useCallback(
    (values = {}) => {
      valuesRef.current = clone(values);
      optionsRef.current = { ...optionsRef.current };
      touchedRef.current = {};
      setErrors({});
      setIsValid(true);
      forceRender(value => value + 1);
      notifySubscribers();
    },
    [notifySubscribers]
  );

  const setValue = useCallback(
    (name, value) => {
      valuesRef.current = {
        ...valuesRef.current,
        [name]: value,
      };
      notifySubscribers(name);
    },
    [notifySubscribers]
  );

  const getValues = useCallback(() => clone(valuesRef.current), []);

  const watch = useCallback(name => {
    if (!name) {
      return clone(valuesRef.current);
    }

    const subscription = {
      name,
      callback: () => forceRender(value => value + 1),
    };

    subscriptionsRef.current.push(subscription);

    return valuesRef.current[name];
  }, []);

  const clearErrors = useCallback(name => {
    if (!name) {
      setErrors({});
      setIsValid(true);
      return;
    }

    setErrors(prevErrors => {
      const nextErrors = { ...prevErrors };
      delete nextErrors[name];
      setIsValid(Object.keys(nextErrors).length === 0);
      return nextErrors;
    });
  }, []);

  const setError = useCallback((name, error) => {
    setErrors(prevErrors => ({
      ...prevErrors,
      [name]: error,
    }));
    setIsValid(false);
  }, []);

  const formState = useMemo(
    () => ({
      errors,
      isSubmitting,
      isValid,
    }),
    [errors, isSubmitting, isValid]
  );

  return {
    register,
    handleSubmit,
    reset,
    setValue,
    getValues,
    watch,
    clearErrors,
    setError,
    formState,
  };
}

module.exports = {
  useForm,
};
