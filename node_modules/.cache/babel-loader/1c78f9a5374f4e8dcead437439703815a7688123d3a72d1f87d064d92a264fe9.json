{"ast":null,"code":"var _jsxFileName = \"/Users/borvel/Documents/GitHub/places-app/src/components/Map/Map.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useCallback } from 'react';\nimport L from 'leaflet';\nimport 'leaflet/dist/leaflet.css';\nimport 'leaflet.markercluster';\nimport 'leaflet.markercluster/dist/MarkerCluster.css';\nimport 'leaflet.markercluster/dist/MarkerCluster.Default.css';\nimport { styled } from 'styled-components';\n\n// Fix for default icon\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\ndelete L.Icon.Default.prototype._getIconUrl;\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\n  iconUrl: require('leaflet/dist/images/marker-icon.png'),\n  shadowUrl: require('leaflet/dist/images/marker-shadow.png')\n});\nconst MapContainer = styled.div`\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 1;\n  will-change: transform;\n  transform: translateZ(0);\n  backface-visibility: hidden;\n  perspective: 1000px;\n\n  /* Дополнительные фиксы для iOS устройств */\n  @supports (-webkit-touch-callout: none) {\n    position: fixed !important;\n    top: 56px !important;\n    bottom: 0 !important;\n    left: 0 !important;\n    right: 0 !important;\n    width: 100% !important;\n    height: calc(100vh - 56px) !important;\n  }\n\n  /* Фикс для всех мобильных устройств */\n  @media (max-width: 768px) {\n    position: fixed !important;\n    top: 56px !important;\n    bottom: 0 !important;\n    left: 0 !important;\n    right: 0 !important;\n    width: 100% !important;\n    height: calc(100vh - 56px) !important;\n  }\n`;\n\n// Создаем стиль для контейнера контента на мобильных устройствах\n_c = MapContainer;\nconst ContentContainer = styled.div`\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n\n  /* Дополнительные фиксы для iOS устройств */\n  @supports (-webkit-touch-callout: none) {\n    position: fixed !important;\n    top: 56px !important;\n    bottom: 0 !important;\n    left: 0 !important;\n    right: 0 !important;\n    width: 100% !important;\n    height: calc(100vh - 56px) !important;\n    overflow: hidden !important;\n  }\n\n  /* Фикс для всех мобильных устройств */\n  @media (max-width: 768px) {\n    position: fixed !important;\n    top: 56px !important;\n    bottom: 0 !important;\n    left: 0 !important;\n    right: 0 !important;\n    width: 100% !important;\n    height: calc(100vh - 56px) !important;\n    overflow: hidden !important;\n  }\n`;\n\n// Расширяем интерфейс MapOptions для поддержки дополнительных свойств\n_c2 = ContentContainer;\nconst createPopupContent = place => `\n  <div class=\"place-card\">\n    <img src=\"${place.image}\" alt=\"${place.name}\" class=\"place-image\" style=\"width: 100%; height: 200px; object-fit: cover;\" />\n    <div class=\"place-content\" style=\"padding: 15px;\">\n      <h3 style=\"margin: 0; font-size: 18px;\">${place.name}</h3>\n      <p style=\"margin: 10px 0; font-size: 14px;\">${place.description}</p>\n      <div class=\"place-links-social\" style=\"margin-top: 10px;\">\n        ${place.instagram ? `<a href=\"${place.instagram}\" target=\"_blank\"><img src=\"/data/images/instagram.svg\" alt=\"Instagram\" style=\"width: 27px; height: 27px;\" /></a>` : ''}\n        ${place.maps_url ? `<a href=\"${place.maps_url}\" target=\"_blank\"><img src=\"/data/images/google.svg\" alt=\"Google Maps\" style=\"width: 27px; height: 27px;\" /></a>` : ''}\n      </div>\n    </div>\n  </div>\n`;\nexport const Map = ({\n  places,\n  config,\n  onMarkerClick,\n  selectedPlace,\n  mapRef,\n  onPopupClose,\n  onBoundsChange\n}) => {\n  _s();\n  const markersRef = useRef(null);\n  const activeMarkerRef = useRef(null);\n  const containerRef = useRef(null);\n  const mobilePopupRef = useRef(null);\n  // Флаг для отслеживания программного закрытия попапа\n  const isProgrammaticClose = useRef(false);\n\n  // Создаем мобильный попап\n  useEffect(() => {\n    if (!mobilePopupRef.current) {\n      const popupDiv = document.createElement('div');\n      popupDiv.className = 'map-popup-mobile';\n      document.body.appendChild(popupDiv);\n      mobilePopupRef.current = popupDiv;\n      return () => {\n        document.body.removeChild(popupDiv);\n        mobilePopupRef.current = null;\n      };\n    }\n  }, []);\n  const showMobilePopup = useCallback(place => {\n    if (!mobilePopupRef.current) return;\n    const popupContent = `\n      <div class=\"place-card\">\n        <img src=\"${place.image}\" alt=\"${place.name}\" class=\"place-image\" />\n        <div class=\"place-content\">\n          <h3>${place.name}</h3>\n          <p>${place.description}</p>\n          <div class=\"place-links-social\">\n            ${place.instagram ? `<a href=\"${place.instagram}\" target=\"_blank\"><img src=\"/data/images/instagram.svg\" alt=\"Instagram\" /></a>` : ''}\n            ${place.maps_url ? `<a href=\"${place.maps_url}\" target=\"_blank\"><img src=\"/data/images/google.svg\" alt=\"Google Maps\" /></a>` : ''}\n          </div>\n        </div>\n        <button class=\"close-btn-mobile\">×</button>\n      </div>\n    `;\n    mobilePopupRef.current.innerHTML = popupContent;\n    mobilePopupRef.current.classList.add('active');\n    const closeBtn = mobilePopupRef.current.querySelector('.close-btn-mobile');\n    if (closeBtn) {\n      closeBtn.addEventListener('click', () => {\n        if (mobilePopupRef.current) {\n          mobilePopupRef.current.classList.remove('active');\n          if (activeMarkerRef.current) {\n            activeMarkerRef.current.setIcon(createDefaultIcon());\n            activeMarkerRef.current = null;\n          }\n\n          // Сообщаем, что попап закрыт, чтобы сбросить selectedPlace\n          if (onPopupClose) {\n            onPopupClose();\n          }\n        }\n      });\n    }\n  }, [onPopupClose]);\n  const createDefaultIcon = useCallback(() => {\n    console.log('Creating default icon');\n    return L.divIcon({\n      className: 'marker-default',\n      iconSize: [30, 30],\n      iconAnchor: [15, 15],\n      html: '<div></div>'\n    });\n  }, []);\n  const createCustomIcon = useCallback(() => {\n    console.log('Creating custom icon');\n    return L.divIcon({\n      className: 'marker-active',\n      iconSize: [30, 40],\n      iconAnchor: [15, 40],\n      popupAnchor: [0, -40],\n      html: '<div></div>'\n    });\n  }, []);\n  const createMarkerClusterGroup = useCallback(() => {\n    console.log('Creating marker cluster group with settings:', config.mapSettings.clusterSettings);\n    return L.markerClusterGroup({\n      iconCreateFunction: cluster => {\n        const count = cluster.getChildCount();\n        return L.divIcon({\n          html: `<div class=\"cluster-icon\">${count}</div>`,\n          className: 'marker-cluster',\n          iconSize: L.point(40, 40)\n        });\n      },\n      disableClusteringAtZoom: config.mapSettings.clusterSettings.disableClusteringAtZoom,\n      spiderfyOnMaxZoom: false,\n      maxClusterRadius: config.mapSettings.clusterSettings.maxClusterRadius,\n      zoomToBoundsOnClick: false,\n      showCoverageOnHover: false,\n      animate: true,\n      animateAddingMarkers: false\n    });\n  }, [config.mapSettings.clusterSettings]);\n  const updateMarkers = useCallback(() => {\n    console.log('Updating markers');\n    if (!mapRef.current || !markersRef.current) return;\n\n    // Очищаем все слои, включая предыдущие маркеры\n    markersRef.current.clearLayers();\n\n    // Сбрасываем активный маркер\n    activeMarkerRef.current = null;\n    const defaultIcon = createDefaultIcon();\n    const customIcon = createCustomIcon();\n\n    // Создаем маркеры с tooltips\n    const markers = [];\n    places.forEach(place => {\n      var _markersRef$current;\n      const marker = L.marker([place.lat, place.lng], {\n        icon: defaultIcon,\n        riseOnHover: true,\n        riseOffset: 250\n      });\n      if (window.innerWidth > 768) {\n        const popup = L.popup({\n          maxWidth: 500,\n          className: 'place-popup',\n          closeButton: true,\n          closeOnClick: false,\n          autoPan: true,\n          autoPanPadding: [50, 50]\n        }).setContent(createPopupContent(place));\n        marker.bindPopup(popup);\n      }\n\n      // Создаем tooltip и делаем его невидимым по умолчанию\n      marker.bindTooltip(place.name, {\n        permanent: true,\n        direction: 'bottom',\n        offset: [0, 5],\n        className: 'place-label',\n        opacity: 0\n      });\n\n      // Добавляем место в данные маркера для доступа в дальнейшем\n      marker.place = place;\n      marker.on('click', () => {\n        var _mapRef$current, _mapRef$current2;\n        console.log('Marker clicked:', place.name);\n\n        // При клике на тот же маркер, отменяем выбор\n        if (activeMarkerRef.current === marker) {\n          marker.setIcon(defaultIcon);\n          if (window.innerWidth > 768) {\n            isProgrammaticClose.current = true;\n            marker.closePopup();\n          }\n          activeMarkerRef.current = null;\n          onMarkerClick(place); // Передаем повторный клик для отмены выбора\n          return;\n        }\n\n        // При клике на другой маркер\n        if (activeMarkerRef.current && activeMarkerRef.current !== marker) {\n          activeMarkerRef.current.setIcon(defaultIcon);\n          if (window.innerWidth > 768) {\n            isProgrammaticClose.current = true;\n            activeMarkerRef.current.closePopup();\n          }\n        }\n        marker.setIcon(customIcon);\n        activeMarkerRef.current = marker;\n\n        // Центрируем карту с проверкой зума\n        const currentZoom = ((_mapRef$current = mapRef.current) === null || _mapRef$current === void 0 ? void 0 : _mapRef$current.getZoom()) || 0;\n        const targetZoom = currentZoom >= 16 ? currentZoom : 16;\n        (_mapRef$current2 = mapRef.current) === null || _mapRef$current2 === void 0 ? void 0 : _mapRef$current2.setView(marker.getLatLng(), targetZoom, {\n          animate: true,\n          duration: 0.5\n        });\n        if (window.innerWidth > 768) {\n          marker.openPopup();\n        } else {\n          showMobilePopup(place);\n        }\n        onMarkerClick(place);\n      });\n      markers.push(marker);\n      (_markersRef$current = markersRef.current) === null || _markersRef$current === void 0 ? void 0 : _markersRef$current.addLayer(marker);\n\n      // Устанавливаем активный маркер для выбранного места\n      if (selectedPlace && selectedPlace.name === place.name) {\n        console.log('Setting active marker for selected place:', place.name);\n        marker.setIcon(customIcon);\n        activeMarkerRef.current = marker;\n        if (window.innerWidth > 768) {\n          marker.openPopup();\n        } else {\n          showMobilePopup(place);\n        }\n      }\n    });\n\n    // Функция для проверки наложения меток\n    const shouldShowLabel = (marker, visibleMarkers) => {\n      var _mapRef$current3;\n      // Одиночные метки всегда показываем\n      if (visibleMarkers.length <= 1) return true;\n      const markerPoint = (_mapRef$current3 = mapRef.current) === null || _mapRef$current3 === void 0 ? void 0 : _mapRef$current3.latLngToContainerPoint(marker.getLatLng());\n      if (!markerPoint) return false;\n\n      // Минимальное расстояние между метками в пикселях\n      const minDistance = 100;\n\n      // Проверяем расстояние до других видимых меток\n      for (const otherMarker of visibleMarkers) {\n        var _mapRef$current4;\n        if (marker === otherMarker) continue;\n        const otherPoint = (_mapRef$current4 = mapRef.current) === null || _mapRef$current4 === void 0 ? void 0 : _mapRef$current4.latLngToContainerPoint(otherMarker.getLatLng());\n        if (!otherPoint) continue;\n        const distance = markerPoint.distanceTo(otherPoint);\n        if (distance < minDistance) {\n          var _mapRef$current5, _mapRef$current6;\n          // Если метки слишком близко, показываем только ту, что ближе к центру экрана\n          const center = (_mapRef$current5 = mapRef.current) === null || _mapRef$current5 === void 0 ? void 0 : _mapRef$current5.getCenter();\n          if (!center) continue;\n          const centerPoint = (_mapRef$current6 = mapRef.current) === null || _mapRef$current6 === void 0 ? void 0 : _mapRef$current6.latLngToContainerPoint(center);\n          if (!centerPoint) continue;\n          const distToCenter = markerPoint.distanceTo(centerPoint);\n          const otherDistToCenter = otherPoint.distanceTo(centerPoint);\n\n          // Если эта метка дальше от центра, скрываем её\n          if (distToCenter > otherDistToCenter) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n\n    // Обновляем видимость названий меток при изменении зума или видимых маркеров\n    const updateLabelsVisibility = () => {\n      if (!mapRef.current || !markersRef.current) return;\n      const zoom = mapRef.current.getZoom();\n      const allMarkers = markers;\n\n      // Для небольшого зума скрываем все названия\n      if (zoom < 14) {\n        allMarkers.forEach(marker => {\n          const tooltip = marker.getTooltip();\n          if (tooltip) tooltip.setOpacity(0);\n        });\n        return;\n      }\n\n      // Получаем все маркеры, которые видны на экране (не в кластерах)\n      const visibleMarkers = [];\n      allMarkers.forEach(marker => {\n        var _markersRef$current2;\n        // Проверяем, является ли родитель маркера кластером\n        const parent = (_markersRef$current2 = markersRef.current) === null || _markersRef$current2 === void 0 ? void 0 : _markersRef$current2.getVisibleParent(marker);\n        if (parent === marker) {\n          visibleMarkers.push(marker);\n        }\n      });\n\n      // Обновляем видимость для каждого видимого маркера\n      visibleMarkers.forEach(marker => {\n        const tooltip = marker.getTooltip();\n        if (!tooltip) return;\n        if (shouldShowLabel(marker, visibleMarkers)) {\n          tooltip.setOpacity(1);\n        } else {\n          tooltip.setOpacity(0);\n        }\n      });\n\n      // Скрываем названия для маркеров в кластерах\n      allMarkers.forEach(marker => {\n        if (!visibleMarkers.includes(marker)) {\n          const tooltip = marker.getTooltip();\n          if (tooltip) tooltip.setOpacity(0);\n        }\n      });\n    };\n\n    // Добавляем обработчик клика на кластер\n    markersRef.current.on('clusterclick', e => {\n      const cluster = e.layer;\n      const childMarkers = cluster.getAllChildMarkers();\n      if (childMarkers.length === 1) {\n        childMarkers[0].fire('click');\n      } else {\n        var _mapRef$current7;\n        (_mapRef$current7 = mapRef.current) === null || _mapRef$current7 === void 0 ? void 0 : _mapRef$current7.setView(cluster.getLatLng(), 16, {\n          animate: true\n        });\n      }\n\n      // Обновляем видимость названий после раскрытия кластера\n      setTimeout(updateLabelsVisibility, 300);\n    });\n\n    // События, при которых нужно обновлять видимость названий\n    mapRef.current.on('zoomend', updateLabelsVisibility);\n    mapRef.current.on('moveend', updateLabelsVisibility);\n    markersRef.current.on('animationend', updateLabelsVisibility);\n\n    // Обновляем сразу после создания маркеров\n    setTimeout(updateLabelsVisibility, 100);\n  }, [places, selectedPlace, createDefaultIcon, createCustomIcon, onMarkerClick, showMobilePopup]);\n  useEffect(() => {\n    console.log('Initializing map');\n    if (!containerRef.current || mapRef.current) return;\n    const map = L.map(containerRef.current, {\n      center: config.mapSettings.center,\n      zoom: config.mapSettings.initialZoom,\n      scrollWheelZoom: true,\n      closePopupOnClick: true,\n      tap: true,\n      attributionControl: false,\n      zoomControl: false,\n      maxZoom: config.mapSettings.maxZoom,\n      minZoom: config.mapSettings.initialZoom - 2,\n      bounceAtZoomLimits: false,\n      touchZoom: 'center',\n      doubleClickZoom: 'center'\n    });\n    L.tileLayer(config.mapSettings.tileLayer.url, {\n      attribution: config.mapSettings.tileLayer.attribution,\n      subdomains: config.mapSettings.tileLayer.subdomains,\n      maxZoom: config.mapSettings.maxZoom,\n      minZoom: config.mapSettings.initialZoom - 2,\n      preferCanvas: true\n    }).addTo(map);\n    L.control.attribution({\n      position: 'bottomright',\n      prefix: false\n    }).addTo(map);\n    L.control.zoom({\n      position: 'topright'\n    }).addTo(map);\n    mapRef.current = map;\n    markersRef.current = createMarkerClusterGroup();\n    map.addLayer(markersRef.current);\n    const handleResize = () => {\n      console.log('Window resized, updating map size');\n      map.invalidateSize({\n        animate: false,\n        pan: false\n      });\n    };\n    window.addEventListener('resize', handleResize);\n    window.addEventListener('orientationchange', handleResize);\n    setTimeout(handleResize, 100);\n    return () => {\n      console.log('Cleaning up map');\n      window.removeEventListener('resize', handleResize);\n      window.removeEventListener('orientationchange', handleResize);\n      map.remove();\n      mapRef.current = null;\n      markersRef.current = null;\n    };\n  }, [config, createMarkerClusterGroup]);\n  useEffect(() => {\n    if (mapRef.current && markersRef.current) {\n      console.log('Updating markers after dependency change');\n      updateMarkers();\n\n      // Добавляем обработчик события закрытия попапа\n      const popupCloseHandler = () => {\n        // Обрабатываем только если закрытие не программное\n        if (!isProgrammaticClose.current) {\n          if (activeMarkerRef.current) {\n            // Только если закрытие инициировано пользователем\n            activeMarkerRef.current.setIcon(createDefaultIcon());\n            activeMarkerRef.current = null;\n\n            // Сообщаем, что попап закрыт пользователем\n            if (onPopupClose) {\n              onPopupClose();\n            }\n          }\n        }\n        // Сбрасываем флаг после использования\n        isProgrammaticClose.current = false;\n      };\n\n      // Удаляем старый обработчик, если он есть, и добавляем новый\n      mapRef.current.off('popupclose');\n      mapRef.current.on('popupclose', popupCloseHandler);\n      return () => {\n        if (mapRef.current) {\n          mapRef.current.off('popupclose', popupCloseHandler);\n        }\n      };\n    }\n  }, [updateMarkers, createDefaultIcon, onPopupClose]);\n\n  // Обрабатываем изменение selectedPlace\n  useEffect(() => {\n    var _markersRef$current3;\n    if (!mapRef.current || !selectedPlace) return;\n\n    // Пытаемся найти маркер для выбранного места\n    const allLayers = ((_markersRef$current3 = markersRef.current) === null || _markersRef$current3 === void 0 ? void 0 : _markersRef$current3.getLayers()) || [];\n    const allMarkers = allLayers;\n\n    // Маркер не найден, обновляем все маркеры\n    if (allMarkers.length === 0) {\n      updateMarkers();\n      return;\n    }\n\n    // Центрируем карту на выбранном месте если selectedPlace изменился\n    const currentZoom = mapRef.current.getZoom();\n    const targetZoom = currentZoom >= 16 ? currentZoom : 16;\n    mapRef.current.setView([selectedPlace.lat, selectedPlace.lng], targetZoom, {\n      animate: true,\n      duration: 0.5\n    });\n  }, [selectedPlace, updateMarkers]);\n\n  // Отслеживаем изменения границ карты\n  useEffect(() => {\n    if (!mapRef.current || !onBoundsChange) return;\n    const handleMove = () => {\n      var _mapRef$current8;\n      const bounds = (_mapRef$current8 = mapRef.current) === null || _mapRef$current8 === void 0 ? void 0 : _mapRef$current8.getBounds();\n      if (bounds) {\n        onBoundsChange(bounds);\n      }\n    };\n    mapRef.current.on('moveend', handleMove);\n    mapRef.current.on('zoomend', handleMove);\n\n    // Вызываем handleMove сразу для установки начальных границ\n    handleMove();\n    return () => {\n      if (mapRef.current) {\n        mapRef.current.off('moveend', handleMove);\n        mapRef.current.off('zoomend', handleMove);\n      }\n    };\n  }, [mapRef, onBoundsChange]);\n  return /*#__PURE__*/_jsxDEV(ContentContainer, {\n    children: /*#__PURE__*/_jsxDEV(MapContainer, {\n      ref: containerRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 592,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 591,\n    columnNumber: 5\n  }, this);\n};\n_s(Map, \"GlxRmMzoMB4I3pNeXpXpuCdor4k=\");\n_c3 = Map;\nexport default Map;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"MapContainer\");\n$RefreshReg$(_c2, \"ContentContainer\");\n$RefreshReg$(_c3, \"Map\");","map":{"version":3,"names":["React","useEffect","useRef","useCallback","L","styled","jsxDEV","_jsxDEV","Icon","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","require","iconUrl","shadowUrl","MapContainer","div","_c","ContentContainer","_c2","createPopupContent","place","image","name","description","instagram","maps_url","Map","places","config","onMarkerClick","selectedPlace","mapRef","onPopupClose","onBoundsChange","_s","markersRef","activeMarkerRef","containerRef","mobilePopupRef","isProgrammaticClose","current","popupDiv","document","createElement","className","body","appendChild","removeChild","showMobilePopup","popupContent","innerHTML","classList","add","closeBtn","querySelector","addEventListener","remove","setIcon","createDefaultIcon","console","log","divIcon","iconSize","iconAnchor","html","createCustomIcon","popupAnchor","createMarkerClusterGroup","mapSettings","clusterSettings","markerClusterGroup","iconCreateFunction","cluster","count","getChildCount","point","disableClusteringAtZoom","spiderfyOnMaxZoom","maxClusterRadius","zoomToBoundsOnClick","showCoverageOnHover","animate","animateAddingMarkers","updateMarkers","clearLayers","defaultIcon","customIcon","markers","forEach","_markersRef$current","marker","lat","lng","icon","riseOnHover","riseOffset","window","innerWidth","popup","maxWidth","closeButton","closeOnClick","autoPan","autoPanPadding","setContent","bindPopup","bindTooltip","permanent","direction","offset","opacity","on","_mapRef$current","_mapRef$current2","closePopup","currentZoom","getZoom","targetZoom","setView","getLatLng","duration","openPopup","push","addLayer","shouldShowLabel","visibleMarkers","_mapRef$current3","length","markerPoint","latLngToContainerPoint","minDistance","otherMarker","_mapRef$current4","otherPoint","distance","distanceTo","_mapRef$current5","_mapRef$current6","center","getCenter","centerPoint","distToCenter","otherDistToCenter","updateLabelsVisibility","zoom","allMarkers","tooltip","getTooltip","setOpacity","_markersRef$current2","parent","getVisibleParent","includes","e","layer","childMarkers","getAllChildMarkers","fire","_mapRef$current7","setTimeout","map","initialZoom","scrollWheelZoom","closePopupOnClick","tap","attributionControl","zoomControl","maxZoom","minZoom","bounceAtZoomLimits","touchZoom","doubleClickZoom","tileLayer","url","attribution","subdomains","preferCanvas","addTo","control","position","prefix","handleResize","invalidateSize","pan","removeEventListener","popupCloseHandler","off","_markersRef$current3","allLayers","getLayers","handleMove","_mapRef$current8","bounds","getBounds","children","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c3","$RefreshReg$"],"sources":["/Users/borvel/Documents/GitHub/places-app/src/components/Map/Map.tsx"],"sourcesContent":["import React, { useEffect, useRef, useCallback } from 'react';\nimport L from 'leaflet';\nimport 'leaflet/dist/leaflet.css';\nimport 'leaflet.markercluster';\nimport 'leaflet.markercluster/dist/MarkerCluster.css';\nimport 'leaflet.markercluster/dist/MarkerCluster.Default.css';\nimport { Place, AppConfig } from '../../types/places';\nimport { styled } from 'styled-components';\n\n// Fix for default icon\ndelete (L.Icon.Default.prototype as any)._getIconUrl;\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\n  iconUrl: require('leaflet/dist/images/marker-icon.png'),\n  shadowUrl: require('leaflet/dist/images/marker-shadow.png'),\n});\n\ninterface MapProps {\n  places: Place[];\n  config: AppConfig;\n  onMarkerClick: (place: Place) => void;\n  selectedPlace?: Place | null;\n  mapRef: React.MutableRefObject<L.Map | null>;\n  onPopupClose?: () => void;\n  onBoundsChange?: (bounds: L.LatLngBounds) => void;\n}\n\nconst MapContainer = styled.div`\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 1;\n  will-change: transform;\n  transform: translateZ(0);\n  backface-visibility: hidden;\n  perspective: 1000px;\n\n  /* Дополнительные фиксы для iOS устройств */\n  @supports (-webkit-touch-callout: none) {\n    position: fixed !important;\n    top: 56px !important;\n    bottom: 0 !important;\n    left: 0 !important;\n    right: 0 !important;\n    width: 100% !important;\n    height: calc(100vh - 56px) !important;\n  }\n\n  /* Фикс для всех мобильных устройств */\n  @media (max-width: 768px) {\n    position: fixed !important;\n    top: 56px !important;\n    bottom: 0 !important;\n    left: 0 !important;\n    right: 0 !important;\n    width: 100% !important;\n    height: calc(100vh - 56px) !important;\n  }\n`;\n\n// Создаем стиль для контейнера контента на мобильных устройствах\nconst ContentContainer = styled.div`\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n\n  /* Дополнительные фиксы для iOS устройств */\n  @supports (-webkit-touch-callout: none) {\n    position: fixed !important;\n    top: 56px !important;\n    bottom: 0 !important;\n    left: 0 !important;\n    right: 0 !important;\n    width: 100% !important;\n    height: calc(100vh - 56px) !important;\n    overflow: hidden !important;\n  }\n\n  /* Фикс для всех мобильных устройств */\n  @media (max-width: 768px) {\n    position: fixed !important;\n    top: 56px !important;\n    bottom: 0 !important;\n    left: 0 !important;\n    right: 0 !important;\n    width: 100% !important;\n    height: calc(100vh - 56px) !important;\n    overflow: hidden !important;\n  }\n`;\n\n// Расширяем интерфейс MapOptions для поддержки дополнительных свойств\ndeclare module 'leaflet' {\n  interface MapOptions {\n    tap?: boolean;\n  }\n\n  interface TileLayerOptions {\n    preferCanvas?: boolean;\n  }\n}\n\nconst createPopupContent = (place: Place) => `\n  <div class=\"place-card\">\n    <img src=\"${place.image}\" alt=\"${place.name}\" class=\"place-image\" style=\"width: 100%; height: 200px; object-fit: cover;\" />\n    <div class=\"place-content\" style=\"padding: 15px;\">\n      <h3 style=\"margin: 0; font-size: 18px;\">${place.name}</h3>\n      <p style=\"margin: 10px 0; font-size: 14px;\">${place.description}</p>\n      <div class=\"place-links-social\" style=\"margin-top: 10px;\">\n        ${place.instagram ? `<a href=\"${place.instagram}\" target=\"_blank\"><img src=\"/data/images/instagram.svg\" alt=\"Instagram\" style=\"width: 27px; height: 27px;\" /></a>` : ''}\n        ${place.maps_url ? `<a href=\"${place.maps_url}\" target=\"_blank\"><img src=\"/data/images/google.svg\" alt=\"Google Maps\" style=\"width: 27px; height: 27px;\" /></a>` : ''}\n      </div>\n    </div>\n  </div>\n`;\n\nexport const Map: React.FC<MapProps> = ({ places, config, onMarkerClick, selectedPlace, mapRef, onPopupClose, onBoundsChange }) => {\n  const markersRef = useRef<L.MarkerClusterGroup | null>(null);\n  const activeMarkerRef = useRef<L.Marker | null>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const mobilePopupRef = useRef<HTMLDivElement | null>(null);\n  // Флаг для отслеживания программного закрытия попапа\n  const isProgrammaticClose = useRef(false);\n\n  // Создаем мобильный попап\n  useEffect(() => {\n    if (!mobilePopupRef.current) {\n      const popupDiv = document.createElement('div');\n      popupDiv.className = 'map-popup-mobile';\n      document.body.appendChild(popupDiv);\n      mobilePopupRef.current = popupDiv;\n\n      return () => {\n        document.body.removeChild(popupDiv);\n        mobilePopupRef.current = null;\n      };\n    }\n  }, []);\n\n  const showMobilePopup = useCallback((place: Place) => {\n    if (!mobilePopupRef.current) return;\n\n    const popupContent = `\n      <div class=\"place-card\">\n        <img src=\"${place.image}\" alt=\"${place.name}\" class=\"place-image\" />\n        <div class=\"place-content\">\n          <h3>${place.name}</h3>\n          <p>${place.description}</p>\n          <div class=\"place-links-social\">\n            ${place.instagram ? `<a href=\"${place.instagram}\" target=\"_blank\"><img src=\"/data/images/instagram.svg\" alt=\"Instagram\" /></a>` : ''}\n            ${place.maps_url ? `<a href=\"${place.maps_url}\" target=\"_blank\"><img src=\"/data/images/google.svg\" alt=\"Google Maps\" /></a>` : ''}\n          </div>\n        </div>\n        <button class=\"close-btn-mobile\">×</button>\n      </div>\n    `;\n\n    mobilePopupRef.current.innerHTML = popupContent;\n    mobilePopupRef.current.classList.add('active');\n\n    const closeBtn = mobilePopupRef.current.querySelector('.close-btn-mobile');\n    if (closeBtn) {\n      closeBtn.addEventListener('click', () => {\n        if (mobilePopupRef.current) {\n          mobilePopupRef.current.classList.remove('active');\n          if (activeMarkerRef.current) {\n            activeMarkerRef.current.setIcon(createDefaultIcon());\n            activeMarkerRef.current = null;\n          }\n\n          // Сообщаем, что попап закрыт, чтобы сбросить selectedPlace\n          if (onPopupClose) {\n            onPopupClose();\n          }\n        }\n      });\n    }\n  }, [onPopupClose]);\n\n  const createDefaultIcon = useCallback(() => {\n    console.log('Creating default icon');\n    return L.divIcon({\n      className: 'marker-default',\n      iconSize: [30, 30],\n      iconAnchor: [15, 15],\n      html: '<div></div>'\n    });\n  }, []);\n\n  const createCustomIcon = useCallback(() => {\n    console.log('Creating custom icon');\n    return L.divIcon({\n      className: 'marker-active',\n      iconSize: [30, 40],\n      iconAnchor: [15, 40],\n      popupAnchor: [0, -40],\n      html: '<div></div>'\n    });\n  }, []);\n\n  const createMarkerClusterGroup = useCallback(() => {\n    console.log('Creating marker cluster group with settings:', config.mapSettings.clusterSettings);\n    return L.markerClusterGroup({\n      iconCreateFunction: (cluster: L.MarkerCluster) => {\n        const count = cluster.getChildCount();\n        return L.divIcon({\n          html: `<div class=\"cluster-icon\">${count}</div>`,\n          className: 'marker-cluster',\n          iconSize: L.point(40, 40)\n        });\n      },\n      disableClusteringAtZoom: config.mapSettings.clusterSettings.disableClusteringAtZoom,\n      spiderfyOnMaxZoom: false,\n      maxClusterRadius: config.mapSettings.clusterSettings.maxClusterRadius,\n      zoomToBoundsOnClick: false,\n      showCoverageOnHover: false,\n      animate: true,\n      animateAddingMarkers: false\n    });\n  }, [config.mapSettings.clusterSettings]);\n\n  const updateMarkers = useCallback(() => {\n    console.log('Updating markers');\n    if (!mapRef.current || !markersRef.current) return;\n\n    // Очищаем все слои, включая предыдущие маркеры\n    markersRef.current.clearLayers();\n\n    // Сбрасываем активный маркер\n    activeMarkerRef.current = null;\n\n    const defaultIcon = createDefaultIcon();\n    const customIcon = createCustomIcon();\n\n    // Создаем маркеры с tooltips\n    const markers: L.Marker[] = [];\n    places.forEach(place => {\n      const marker = L.marker([place.lat, place.lng], {\n        icon: defaultIcon,\n        riseOnHover: true,\n        riseOffset: 250\n      });\n\n      if (window.innerWidth > 768) {\n        const popup = L.popup({\n          maxWidth: 500,\n          className: 'place-popup',\n          closeButton: true,\n          closeOnClick: false,\n          autoPan: true,\n          autoPanPadding: [50, 50]\n        }).setContent(createPopupContent(place));\n\n        marker.bindPopup(popup);\n      }\n\n      // Создаем tooltip и делаем его невидимым по умолчанию\n      marker.bindTooltip(place.name, {\n        permanent: true,\n        direction: 'bottom',\n        offset: [0, 5],\n        className: 'place-label',\n        opacity: 0\n      });\n\n      // Добавляем место в данные маркера для доступа в дальнейшем\n      (marker as any).place = place;\n\n      marker.on('click', () => {\n        console.log('Marker clicked:', place.name);\n\n        // При клике на тот же маркер, отменяем выбор\n        if (activeMarkerRef.current === marker) {\n          marker.setIcon(defaultIcon);\n          if (window.innerWidth > 768) {\n            isProgrammaticClose.current = true;\n            marker.closePopup();\n          }\n          activeMarkerRef.current = null;\n          onMarkerClick(place); // Передаем повторный клик для отмены выбора\n          return;\n        }\n\n        // При клике на другой маркер\n        if (activeMarkerRef.current && activeMarkerRef.current !== marker) {\n          activeMarkerRef.current.setIcon(defaultIcon);\n          if (window.innerWidth > 768) {\n            isProgrammaticClose.current = true;\n            activeMarkerRef.current.closePopup();\n          }\n        }\n\n        marker.setIcon(customIcon);\n        activeMarkerRef.current = marker;\n\n        // Центрируем карту с проверкой зума\n        const currentZoom = mapRef.current?.getZoom() || 0;\n        const targetZoom = currentZoom >= 16 ? currentZoom : 16;\n\n        mapRef.current?.setView(marker.getLatLng(), targetZoom, {\n          animate: true,\n          duration: 0.5\n        });\n\n        if (window.innerWidth > 768) {\n          marker.openPopup();\n        } else {\n          showMobilePopup(place);\n        }\n\n        onMarkerClick(place);\n      });\n\n      markers.push(marker);\n      markersRef.current?.addLayer(marker);\n\n      // Устанавливаем активный маркер для выбранного места\n      if (selectedPlace && selectedPlace.name === place.name) {\n        console.log('Setting active marker for selected place:', place.name);\n        marker.setIcon(customIcon);\n        activeMarkerRef.current = marker;\n\n        if (window.innerWidth > 768) {\n          marker.openPopup();\n        } else {\n          showMobilePopup(place);\n        }\n      }\n    });\n\n    // Функция для проверки наложения меток\n    const shouldShowLabel = (marker: L.Marker, visibleMarkers: L.Marker[]): boolean => {\n      // Одиночные метки всегда показываем\n      if (visibleMarkers.length <= 1) return true;\n\n      const markerPoint = mapRef.current?.latLngToContainerPoint(marker.getLatLng());\n      if (!markerPoint) return false;\n\n      // Минимальное расстояние между метками в пикселях\n      const minDistance = 100;\n\n      // Проверяем расстояние до других видимых меток\n      for (const otherMarker of visibleMarkers) {\n        if (marker === otherMarker) continue;\n\n        const otherPoint = mapRef.current?.latLngToContainerPoint(otherMarker.getLatLng());\n        if (!otherPoint) continue;\n\n        const distance = markerPoint.distanceTo(otherPoint);\n        if (distance < minDistance) {\n          // Если метки слишком близко, показываем только ту, что ближе к центру экрана\n          const center = mapRef.current?.getCenter();\n          if (!center) continue;\n\n          const centerPoint = mapRef.current?.latLngToContainerPoint(center);\n          if (!centerPoint) continue;\n\n          const distToCenter = markerPoint.distanceTo(centerPoint);\n          const otherDistToCenter = otherPoint.distanceTo(centerPoint);\n\n          // Если эта метка дальше от центра, скрываем её\n          if (distToCenter > otherDistToCenter) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    };\n\n    // Обновляем видимость названий меток при изменении зума или видимых маркеров\n    const updateLabelsVisibility = () => {\n      if (!mapRef.current || !markersRef.current) return;\n\n      const zoom = mapRef.current.getZoom();\n      const allMarkers = markers;\n\n      // Для небольшого зума скрываем все названия\n      if (zoom < 14) {\n        allMarkers.forEach(marker => {\n          const tooltip = marker.getTooltip();\n          if (tooltip) tooltip.setOpacity(0);\n        });\n        return;\n      }\n\n      // Получаем все маркеры, которые видны на экране (не в кластерах)\n      const visibleMarkers: L.Marker[] = [];\n      allMarkers.forEach(marker => {\n        // Проверяем, является ли родитель маркера кластером\n        const parent = markersRef.current?.getVisibleParent(marker);\n        if (parent === marker) {\n          visibleMarkers.push(marker);\n        }\n      });\n\n      // Обновляем видимость для каждого видимого маркера\n      visibleMarkers.forEach(marker => {\n        const tooltip = marker.getTooltip();\n        if (!tooltip) return;\n\n        if (shouldShowLabel(marker, visibleMarkers)) {\n          tooltip.setOpacity(1);\n        } else {\n          tooltip.setOpacity(0);\n        }\n      });\n\n      // Скрываем названия для маркеров в кластерах\n      allMarkers.forEach(marker => {\n        if (!visibleMarkers.includes(marker)) {\n          const tooltip = marker.getTooltip();\n          if (tooltip) tooltip.setOpacity(0);\n        }\n      });\n    };\n\n    // Добавляем обработчик клика на кластер\n    markersRef.current.on('clusterclick', (e: L.LeafletEvent) => {\n      const cluster = e.layer as L.MarkerCluster;\n      const childMarkers = cluster.getAllChildMarkers();\n\n      if (childMarkers.length === 1) {\n        childMarkers[0].fire('click');\n      } else {\n        mapRef.current?.setView(cluster.getLatLng(), 16, { animate: true });\n      }\n\n      // Обновляем видимость названий после раскрытия кластера\n      setTimeout(updateLabelsVisibility, 300);\n    });\n\n    // События, при которых нужно обновлять видимость названий\n    mapRef.current.on('zoomend', updateLabelsVisibility);\n    mapRef.current.on('moveend', updateLabelsVisibility);\n    markersRef.current.on('animationend', updateLabelsVisibility);\n\n    // Обновляем сразу после создания маркеров\n    setTimeout(updateLabelsVisibility, 100);\n  }, [places, selectedPlace, createDefaultIcon, createCustomIcon, onMarkerClick, showMobilePopup]);\n\n  useEffect(() => {\n    console.log('Initializing map');\n    if (!containerRef.current || mapRef.current) return;\n\n    const map = L.map(containerRef.current, {\n      center: config.mapSettings.center,\n      zoom: config.mapSettings.initialZoom,\n      scrollWheelZoom: true,\n      closePopupOnClick: true,\n      tap: true,\n      attributionControl: false,\n      zoomControl: false,\n      maxZoom: config.mapSettings.maxZoom,\n      minZoom: config.mapSettings.initialZoom - 2,\n      bounceAtZoomLimits: false,\n      touchZoom: 'center',\n      doubleClickZoom: 'center'\n    });\n\n    L.tileLayer(config.mapSettings.tileLayer.url, {\n      attribution: config.mapSettings.tileLayer.attribution,\n      subdomains: config.mapSettings.tileLayer.subdomains,\n      maxZoom: config.mapSettings.maxZoom,\n      minZoom: config.mapSettings.initialZoom - 2,\n      preferCanvas: true\n    }).addTo(map);\n\n    L.control.attribution({\n      position: 'bottomright',\n      prefix: false\n    }).addTo(map);\n\n    L.control.zoom({\n      position: 'topright'\n    }).addTo(map);\n\n    mapRef.current = map;\n    markersRef.current = createMarkerClusterGroup();\n    map.addLayer(markersRef.current);\n\n    const handleResize = () => {\n      console.log('Window resized, updating map size');\n      map.invalidateSize({ animate: false, pan: false });\n    };\n\n    window.addEventListener('resize', handleResize);\n    window.addEventListener('orientationchange', handleResize);\n\n    setTimeout(handleResize, 100);\n\n    return () => {\n      console.log('Cleaning up map');\n      window.removeEventListener('resize', handleResize);\n      window.removeEventListener('orientationchange', handleResize);\n      map.remove();\n      mapRef.current = null;\n      markersRef.current = null;\n    };\n  }, [config, createMarkerClusterGroup]);\n\n  useEffect(() => {\n    if (mapRef.current && markersRef.current) {\n      console.log('Updating markers after dependency change');\n      updateMarkers();\n\n      // Добавляем обработчик события закрытия попапа\n      const popupCloseHandler = () => {\n        // Обрабатываем только если закрытие не программное\n        if (!isProgrammaticClose.current) {\n          if (activeMarkerRef.current) {\n            // Только если закрытие инициировано пользователем\n            activeMarkerRef.current.setIcon(createDefaultIcon());\n            activeMarkerRef.current = null;\n\n            // Сообщаем, что попап закрыт пользователем\n            if (onPopupClose) {\n              onPopupClose();\n            }\n          }\n        }\n        // Сбрасываем флаг после использования\n        isProgrammaticClose.current = false;\n      };\n\n      // Удаляем старый обработчик, если он есть, и добавляем новый\n      mapRef.current.off('popupclose');\n      mapRef.current.on('popupclose', popupCloseHandler);\n\n      return () => {\n        if (mapRef.current) {\n          mapRef.current.off('popupclose', popupCloseHandler);\n        }\n      };\n    }\n  }, [updateMarkers, createDefaultIcon, onPopupClose]);\n\n  // Обрабатываем изменение selectedPlace\n  useEffect(() => {\n    if (!mapRef.current || !selectedPlace) return;\n\n    // Пытаемся найти маркер для выбранного места\n    const allLayers = markersRef.current?.getLayers() || [];\n    const allMarkers = allLayers as L.Marker[];\n\n    // Маркер не найден, обновляем все маркеры\n    if (allMarkers.length === 0) {\n      updateMarkers();\n      return;\n    }\n\n    // Центрируем карту на выбранном месте если selectedPlace изменился\n    const currentZoom = mapRef.current.getZoom();\n    const targetZoom = currentZoom >= 16 ? currentZoom : 16;\n\n    mapRef.current.setView([selectedPlace.lat, selectedPlace.lng], targetZoom, {\n      animate: true,\n      duration: 0.5\n    });\n  }, [selectedPlace, updateMarkers]);\n\n  // Отслеживаем изменения границ карты\n  useEffect(() => {\n    if (!mapRef.current || !onBoundsChange) return;\n\n    const handleMove = () => {\n      const bounds = mapRef.current?.getBounds();\n      if (bounds) {\n        onBoundsChange(bounds);\n      }\n    };\n\n    mapRef.current.on('moveend', handleMove);\n    mapRef.current.on('zoomend', handleMove);\n\n    // Вызываем handleMove сразу для установки начальных границ\n    handleMove();\n\n    return () => {\n      if (mapRef.current) {\n        mapRef.current.off('moveend', handleMove);\n        mapRef.current.off('zoomend', handleMove);\n      }\n    };\n  }, [mapRef, onBoundsChange]);\n\n  return (\n    <ContentContainer>\n      <MapContainer ref={containerRef} />\n    </ContentContainer>\n  );\n};\n\nexport default Map;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}