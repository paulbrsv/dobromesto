{"ast":null,"code":"import{useEffect,useCallback}from'react';import{useSearchParams}from'react-router-dom';// Глобальная Map для хранения состояния фильтров в UI\nif(!window.filterStates){window.filterStates=new Map();}export const useUrlFilters=(activeFilters,onFilterChange,filterCounts)=>{var _window$places;const[searchParams,setSearchParams]=useSearchParams();// Функция для подсчета базовых счетчиков\nconst calculateBaseCounts=places=>{const counts={};places.forEach(place=>{place.attributes.forEach(attr=>{counts[attr]=(counts[attr]||0)+1;});});return counts;};// Функция для проверки фильтров из URL и удаления невалидных\nconst validateUrlFilters=useCallback(()=>{if(!window.places||window.places.length===0)return;const filtersFromUrl=searchParams.get('filter');if(!filtersFromUrl){// Если нет фильтров в URL, сбрасываем активные фильтры\nonFilterChange([]);return;}const allFilters=filtersFromUrl.split(',');// Проверяем фильтры последовательно\nconst validFilters=[];let currentFilteredPlaces=[...window.places];for(const filter of allFilters){// Проверяем, останутся ли места после применения этого фильтра\nconst placesWithFilter=currentFilteredPlaces.filter(place=>place.attributes.includes(filter));if(placesWithFilter.length>0){// Фильтр валидный - добавляем его и обновляем текущий список мест\nvalidFilters.push(filter);currentFilteredPlaces=placesWithFilter;}}// Если список валидных фильтров изменился, обновляем URL\nif(validFilters.length!==allFilters.length){if(validFilters.length===0){// Если не осталось валидных фильтров, удаляем параметр filter из URL\nconst path=window.location.pathname;window.history.pushState({},'',path);// Вызываем событие для React Router\nwindow.dispatchEvent(new Event('popstate'));}else{// Обновляем URL только с валидными фильтрами\nconst path=window.location.pathname;const newURL=`${path}?filter=${validFilters.join(',')}`;window.history.pushState({},'',newURL);// Вызываем событие для React Router\nwindow.dispatchEvent(new Event('popstate'));}}// Обновляем активные фильтры в UI\nonFilterChange(validFilters);},[searchParams,onFilterChange,setSearchParams]);// Проверяем фильтры при изменении URL или загрузке данных\nuseEffect(()=>{validateUrlFilters();},[searchParams,validateUrlFilters,(_window$places=window.places)===null||_window$places===void 0?void 0:_window$places.length]);// Проверка доступности фильтра\nconst isFilterAvailable=useCallback(filter=>{if(!window.places||window.places.length===0)return false;// Если фильтр уже активен, он всегда доступен\nif(activeFilters.includes(filter))return true;// Получаем текущий отфильтрованный список мест\nlet currentPlaces=[...window.places];// Применяем все активные фильтры последовательно\nfor(const activeFilter of activeFilters){currentPlaces=currentPlaces.filter(place=>place.attributes.includes(activeFilter));}// Проверяем, останутся ли места после применения нового фильтра\nconst placesWithNewFilter=currentPlaces.filter(place=>place.attributes.includes(filter));return placesWithNewFilter.length>0;},[activeFilters]);// Переключение фильтра\nconst toggleFilter=useCallback(filter=>{var _searchParams$get;if(!window.places||window.places.length===0)return;// Получаем текущий список фильтров из URL\nconst currentFilters=((_searchParams$get=searchParams.get('filter'))===null||_searchParams$get===void 0?void 0:_searchParams$get.split(',').filter(Boolean))||[];if(currentFilters.includes(filter)){// Если фильтр уже активен, удаляем его\nconst newFilters=currentFilters.filter(f=>f!==filter);if(newFilters.length===0){// Если не осталось фильтров, удаляем параметр filter из URL\nconst path=window.location.pathname;window.history.pushState({},'',path);// Вызываем событие для React Router\nwindow.dispatchEvent(new Event('popstate'));}else{// Обновляем URL с оставшимися фильтрами\nconst path=window.location.pathname;const newURL=`${path}?filter=${newFilters.join(',')}`;window.history.pushState({},'',newURL);// Вызываем событие для React Router\nwindow.dispatchEvent(new Event('popstate'));}}else{// Если фильтр неактивен, проверяем, можно ли его добавить\nif(isFilterAvailable(filter)){// Добавляем фильтр к текущим\nconst newFilters=[...currentFilters,filter];const path=window.location.pathname;const newURL=`${path}?filter=${newFilters.join(',')}`;window.history.pushState({},'',newURL);// Вызываем событие для React Router\nwindow.dispatchEvent(new Event('popstate'));}}},[searchParams,isFilterAvailable]);// Сброс всех фильтров\nconst resetFilters=useCallback(()=>{const path=window.location.pathname;window.history.pushState({},'',path);// Вызываем событие для React Router\nwindow.dispatchEvent(new Event('popstate'));},[]);return{toggleFilter,isFilterAvailable,resetFilters};};// Добавляем типы для window\nexport default useUrlFilters;","map":{"version":3,"names":["useEffect","useCallback","useSearchParams","window","filterStates","Map","useUrlFilters","activeFilters","onFilterChange","filterCounts","_window$places","searchParams","setSearchParams","calculateBaseCounts","places","counts","forEach","place","attributes","attr","validateUrlFilters","length","filtersFromUrl","get","allFilters","split","validFilters","currentFilteredPlaces","filter","placesWithFilter","includes","push","path","location","pathname","history","pushState","dispatchEvent","Event","newURL","join","isFilterAvailable","currentPlaces","activeFilter","placesWithNewFilter","toggleFilter","_searchParams$get","currentFilters","Boolean","newFilters","f","resetFilters"],"sources":["/Users/borvel/Documents/GitHub/places-app/src/hooks/useUrlFilters.ts"],"sourcesContent":["import { useEffect, useCallback } from 'react';\nimport { useSearchParams } from 'react-router-dom';\nimport { Place } from '../types/places';\n\n// Глобальная Map для хранения состояния фильтров в UI\nif (!window.filterStates) {\n  window.filterStates = new Map<string, boolean>();\n}\n\nexport const useUrlFilters = (\n  activeFilters: string[],\n  onFilterChange: (filters: string[]) => void,\n  filterCounts: Record<string, number>\n) => {\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  // Функция для подсчета базовых счетчиков\n  const calculateBaseCounts = (places: Place[]) => {\n    const counts: Record<string, number> = {};\n    \n    places.forEach(place => {\n      place.attributes.forEach(attr => {\n        counts[attr] = (counts[attr] || 0) + 1;\n      });\n    });\n    \n    return counts;\n  };\n\n  // Функция для проверки фильтров из URL и удаления невалидных\n  const validateUrlFilters = useCallback(() => {\n    if (!window.places || window.places.length === 0) return;\n\n    const filtersFromUrl = searchParams.get('filter');\n    \n    if (!filtersFromUrl) {\n      // Если нет фильтров в URL, сбрасываем активные фильтры\n      onFilterChange([]);\n      return;\n    }\n\n    const allFilters = filtersFromUrl.split(',');\n    \n    // Проверяем фильтры последовательно\n    const validFilters: string[] = [];\n    let currentFilteredPlaces = [...window.places];\n\n    for (const filter of allFilters) {\n      // Проверяем, останутся ли места после применения этого фильтра\n      const placesWithFilter = currentFilteredPlaces.filter(place => \n        place.attributes.includes(filter)\n      );\n\n      if (placesWithFilter.length > 0) {\n        // Фильтр валидный - добавляем его и обновляем текущий список мест\n        validFilters.push(filter);\n        currentFilteredPlaces = placesWithFilter;\n      }\n    }\n\n    // Если список валидных фильтров изменился, обновляем URL\n    if (validFilters.length !== allFilters.length) {\n      if (validFilters.length === 0) {\n        // Если не осталось валидных фильтров, удаляем параметр filter из URL\n        const path = window.location.pathname;\n        window.history.pushState({}, '', path);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      } else {\n        // Обновляем URL только с валидными фильтрами\n        const path = window.location.pathname;\n        const newURL = `${path}?filter=${validFilters.join(',')}`;\n        window.history.pushState({}, '', newURL);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      }\n    }\n\n    // Обновляем активные фильтры в UI\n    onFilterChange(validFilters);\n  }, [searchParams, onFilterChange, setSearchParams]);\n\n  // Проверяем фильтры при изменении URL или загрузке данных\n  useEffect(() => {\n    validateUrlFilters();\n  }, [searchParams, validateUrlFilters, window.places?.length]);\n\n  // Проверка доступности фильтра\n  const isFilterAvailable = useCallback((filter: string) => {\n    if (!window.places || window.places.length === 0) return false;\n\n    // Если фильтр уже активен, он всегда доступен\n    if (activeFilters.includes(filter)) return true;\n\n    // Получаем текущий отфильтрованный список мест\n    let currentPlaces = [...window.places];\n    \n    // Применяем все активные фильтры последовательно\n    for (const activeFilter of activeFilters) {\n      currentPlaces = currentPlaces.filter(place => \n        place.attributes.includes(activeFilter)\n      );\n    }\n\n    // Проверяем, останутся ли места после применения нового фильтра\n    const placesWithNewFilter = currentPlaces.filter(place => \n      place.attributes.includes(filter)\n    );\n\n    return placesWithNewFilter.length > 0;\n  }, [activeFilters]);\n\n  // Переключение фильтра\n  const toggleFilter = useCallback((filter: string) => {\n    if (!window.places || window.places.length === 0) return;\n\n    // Получаем текущий список фильтров из URL\n    const currentFilters = searchParams.get('filter')?.split(',').filter(Boolean) || [];\n    \n    if (currentFilters.includes(filter)) {\n      // Если фильтр уже активен, удаляем его\n      const newFilters = currentFilters.filter(f => f !== filter);\n      \n      if (newFilters.length === 0) {\n        // Если не осталось фильтров, удаляем параметр filter из URL\n        const path = window.location.pathname;\n        window.history.pushState({}, '', path);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      } else {\n        // Обновляем URL с оставшимися фильтрами\n        const path = window.location.pathname;\n        const newURL = `${path}?filter=${newFilters.join(',')}`;\n        window.history.pushState({}, '', newURL);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      }\n    } else {\n      // Если фильтр неактивен, проверяем, можно ли его добавить\n      if (isFilterAvailable(filter)) {\n        // Добавляем фильтр к текущим\n        const newFilters = [...currentFilters, filter];\n        const path = window.location.pathname;\n        const newURL = `${path}?filter=${newFilters.join(',')}`;\n        window.history.pushState({}, '', newURL);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      }\n    }\n  }, [searchParams, isFilterAvailable]);\n\n  // Сброс всех фильтров\n  const resetFilters = useCallback(() => {\n    const path = window.location.pathname;\n    window.history.pushState({}, '', path);\n    // Вызываем событие для React Router\n    window.dispatchEvent(new Event('popstate'));\n  }, []);\n\n  return {\n    toggleFilter,\n    isFilterAvailable,\n    resetFilters\n  };\n};\n\n// Добавляем типы для window\ndeclare global {\n  interface Window {\n    filterStates: Map<string, boolean>;\n    places: Place[];\n  }\n}\n\nexport default useUrlFilters; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}