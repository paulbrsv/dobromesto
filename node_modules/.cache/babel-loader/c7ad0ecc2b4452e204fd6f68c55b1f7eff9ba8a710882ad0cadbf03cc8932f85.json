{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useCallback, useRef } from 'react';\nimport { useSearchParams } from 'react-router-dom';\n// Глобальная Map для хранения состояния фильтров в UI\nif (!window.filterStates) {\n  window.filterStates = new Map();\n}\nexport const useUrlFilters = (activeFilters, onFilterChange, filterCounts) => {\n  _s();\n  var _window$places3;\n  const [searchParams, setSearchParams] = useSearchParams();\n  // Используем ref для отслеживания первого рендера\n  const isInitialMount = useRef(true);\n\n  // Функция для проверки валидности фильтров\n  const getValidFilters = useCallback(currentFilters => {\n    var _window$places;\n    if (!((_window$places = window.places) !== null && _window$places !== void 0 && _window$places.length)) return [];\n\n    // Если нет фильтров, то возвращаем пустой массив\n    if (!currentFilters.length) return [];\n\n    // Создаем результирующий массив валидных фильтров\n    const validFilters = [];\n\n    // Постепенно фильтруем места, применяя каждый фильтр последовательно\n    let filteredPlaces = [...window.places];\n\n    // Проверяем каждый фильтр последовательно\n    for (const filter of currentFilters) {\n      // Получаем места, соответствующие текущему фильтру из уже отфильтрованных\n      const placesWithFilter = filteredPlaces.filter(place => place.attributes.includes(filter));\n\n      // Если есть хотя бы одно место с этим фильтром, считаем его валидным\n      if (placesWithFilter.length > 0) {\n        validFilters.push(filter);\n        filteredPlaces = placesWithFilter; // Обновляем список мест для следующего фильтра\n      }\n    }\n    return validFilters;\n  }, []);\n\n  // Эффект для инициализации визуального состояния фильтров\n  useEffect(() => {\n    var _window$places2;\n    // Проверяем, что места загружены и счетчики фильтров рассчитаны\n    if ((_window$places2 = window.places) !== null && _window$places2 !== void 0 && _window$places2.length && Object.keys(filterCounts).length > 0) {\n      // Сбрасываем состояния фильтров\n      window.filterStates.clear();\n\n      // Проходим по всем фильтрам и устанавливаем их состояние\n      Object.keys(filterCounts).forEach(filter => {\n        if (filterCounts[filter] > 0) {\n          window.filterStates.set(filter, true);\n        }\n      });\n    }\n  }, [filterCounts, (_window$places3 = window.places) === null || _window$places3 === void 0 ? void 0 : _window$places3.length]);\n\n  // Функция для прямого установления URL с некодированными запятыми\n  const setFiltersInUrl = useCallback(filters => {\n    if (!filters || filters.length === 0) {\n      // Удаляем параметр filter из URL\n      const path = window.location.pathname;\n      window.history.pushState({}, '', path);\n\n      // Принудительно обновляем React Router\n      window.dispatchEvent(new Event('popstate'));\n      return;\n    }\n\n    // Используем history API для прямого изменения URL без кодирования запятых\n    const path = window.location.pathname;\n    const newUrl = `${path}?filter=${filters.join(',')}`;\n    window.history.pushState({}, '', newUrl);\n\n    // Принудительно обновляем React Router\n    window.dispatchEvent(new Event('popstate'));\n  }, []);\n\n  // Обработка изменений URL\n  useEffect(() => {\n    var _window$places4;\n    if (!((_window$places4 = window.places) !== null && _window$places4 !== void 0 && _window$places4.length)) return;\n\n    // Получаем фильтры из URL\n    const filtersFromUrl = searchParams.get('filter');\n\n    // Если URL пустой, сбрасываем все фильтры\n    if (!filtersFromUrl) {\n      window.filterStates.clear();\n      if (activeFilters.length > 0) {\n        // Только если есть активные фильтры\n        onFilterChange([]);\n      }\n      return;\n    }\n\n    // Получаем список фильтров из URL\n    const requestedFilters = filtersFromUrl.split(',').filter(Boolean);\n\n    // Проверяем, все ли фильтры валидны\n    const validFilters = getValidFilters(requestedFilters);\n\n    // Если есть невалидные фильтры, обновляем URL\n    if (validFilters.join(',') !== requestedFilters.join(',')) {\n      if (validFilters.length > 0) {\n        setFiltersInUrl(validFilters);\n      } else {\n        setFiltersInUrl(null);\n      }\n\n      // Останавливаем выполнение, т.к. изменение URL вызовет повторный запуск useEffect\n      return;\n    }\n\n    // Проверяем, изменились ли фильтры\n    const currentActiveFiltersStr = activeFilters.sort().join(',');\n    const newValidFiltersStr = validFilters.sort().join(',');\n\n    // Обновляем UI-состояние\n    window.filterStates.clear();\n    validFilters.forEach(filter => {\n      window.filterStates.set(filter, true);\n    });\n\n    // Вызываем коллбэк только если фильтры изменились\n    if (currentActiveFiltersStr !== newValidFiltersStr) {\n      onFilterChange(validFilters);\n    }\n  }, [searchParams, onFilterChange, getValidFilters, setFiltersInUrl, activeFilters]);\n\n  // Обработка клика по фильтру\n  const toggleFilter = useCallback(filter => {\n    var _window$places5;\n    if (!((_window$places5 = window.places) !== null && _window$places5 !== void 0 && _window$places5.length)) return;\n\n    // Получаем текущие фильтры из URL\n    const urlFilter = searchParams.get('filter') || '';\n    const currentFilters = urlFilter ? urlFilter.split(',').filter(Boolean) : [];\n    const isActive = currentFilters.includes(filter);\n    if (isActive) {\n      // Удаляем фильтр из списка\n      const newFilters = currentFilters.filter(f => f !== filter);\n\n      // Обновляем UI-состояние\n      window.filterStates.delete(filter);\n\n      // Проверяем, изменились ли фильтры\n      if (newFilters.join(',') !== currentFilters.join(',')) {\n        // Обновляем URL\n        if (newFilters.length > 0) {\n          setFiltersInUrl(newFilters);\n        } else {\n          setFiltersInUrl(null);\n        }\n      }\n    } else {\n      // Добавляем фильтр, только если у него есть места (счетчик > 0)\n      if (filterCounts[filter] && filterCounts[filter] > 0) {\n        // Проверяем, будет ли фильтр валидным при добавлении\n        const newFilters = [...currentFilters, filter];\n        const validFilters = getValidFilters(newFilters);\n\n        // Добавляем фильтр только если он валиден в контексте текущих фильтров\n        if (validFilters.includes(filter)) {\n          // Обновляем UI-состояние\n          window.filterStates.set(filter, true);\n\n          // Проверяем, изменились ли фильтры\n          if (validFilters.join(',') !== currentFilters.join(',')) {\n            // Обновляем URL\n            setFiltersInUrl(validFilters);\n          }\n        }\n      }\n    }\n  }, [searchParams, filterCounts, getValidFilters, setFiltersInUrl]);\n\n  // Функция для полного сброса фильтров\n  const resetFilters = useCallback(() => {\n    // Полностью очищаем состояние\n    window.filterStates.clear();\n\n    // Очищаем URL\n    setFiltersInUrl(null);\n  }, [setFiltersInUrl]);\n  return {\n    toggleFilter,\n    isFilterAvailable: useCallback(filter => {\n      // Если фильтр уже активен, он доступен\n      if (activeFilters.includes(filter)) {\n        return true;\n      }\n\n      // Иначе проверяем, есть ли для него места\n      return (filterCounts[filter] || 0) > 0;\n    }, [activeFilters]),\n    resetFilters\n  };\n};\n\n// Добавляем типы для window\n_s(useUrlFilters, \"qqF5GaH3yJw/FKZm/iEeZ8Py57Y=\", false, function () {\n  return [useSearchParams];\n});\nexport default useUrlFilters;","map":{"version":3,"names":["useEffect","useCallback","useRef","useSearchParams","window","filterStates","Map","useUrlFilters","activeFilters","onFilterChange","filterCounts","_s","_window$places3","searchParams","setSearchParams","isInitialMount","getValidFilters","currentFilters","_window$places","places","length","validFilters","filteredPlaces","filter","placesWithFilter","place","attributes","includes","push","_window$places2","Object","keys","clear","forEach","set","setFiltersInUrl","filters","path","location","pathname","history","pushState","dispatchEvent","Event","newUrl","join","_window$places4","filtersFromUrl","get","requestedFilters","split","Boolean","currentActiveFiltersStr","sort","newValidFiltersStr","toggleFilter","_window$places5","urlFilter","isActive","newFilters","f","delete","resetFilters","isFilterAvailable"],"sources":["/Users/borvel/Documents/GitHub/places-app/src/hooks/useUrlFilters.ts"],"sourcesContent":["import { useEffect, useCallback, useRef } from 'react';\nimport { useSearchParams } from 'react-router-dom';\nimport { Place } from '../types/places';\n\n// Глобальная Map для хранения состояния фильтров в UI\nif (!window.filterStates) {\n  window.filterStates = new Map<string, boolean>();\n}\n\nexport const useUrlFilters = (\n  activeFilters: string[],\n  onFilterChange: (filters: string[]) => void,\n  filterCounts: Record<string, number>\n) => {\n  const [searchParams, setSearchParams] = useSearchParams();\n  // Используем ref для отслеживания первого рендера\n  const isInitialMount = useRef(true);\n\n  // Функция для проверки валидности фильтров\n  const getValidFilters = useCallback((currentFilters: string[]) => {\n    if (!window.places?.length) return [];\n    \n    // Если нет фильтров, то возвращаем пустой массив\n    if (!currentFilters.length) return [];\n    \n    // Создаем результирующий массив валидных фильтров\n    const validFilters: string[] = [];\n    \n    // Постепенно фильтруем места, применяя каждый фильтр последовательно\n    let filteredPlaces = [...window.places];\n    \n    // Проверяем каждый фильтр последовательно\n    for (const filter of currentFilters) {\n      // Получаем места, соответствующие текущему фильтру из уже отфильтрованных\n      const placesWithFilter = filteredPlaces.filter(place => \n        place.attributes.includes(filter)\n      );\n      \n      // Если есть хотя бы одно место с этим фильтром, считаем его валидным\n      if (placesWithFilter.length > 0) {\n        validFilters.push(filter);\n        filteredPlaces = placesWithFilter; // Обновляем список мест для следующего фильтра\n      }\n    }\n    \n    return validFilters;\n  }, []);\n\n  // Эффект для инициализации визуального состояния фильтров\n  useEffect(() => {\n    // Проверяем, что места загружены и счетчики фильтров рассчитаны\n    if (window.places?.length && Object.keys(filterCounts).length > 0) {\n      // Сбрасываем состояния фильтров\n      window.filterStates.clear();\n      \n      // Проходим по всем фильтрам и устанавливаем их состояние\n      Object.keys(filterCounts).forEach(filter => {\n        if (filterCounts[filter] > 0) {\n          window.filterStates.set(filter, true);\n        }\n      });\n    }\n  }, [filterCounts, window.places?.length]);\n\n  // Функция для прямого установления URL с некодированными запятыми\n  const setFiltersInUrl = useCallback((filters: string[] | null) => {\n    if (!filters || filters.length === 0) {\n      // Удаляем параметр filter из URL\n      const path = window.location.pathname;\n      window.history.pushState({}, '', path);\n      \n      // Принудительно обновляем React Router\n      window.dispatchEvent(new Event('popstate'));\n      return;\n    }\n\n    // Используем history API для прямого изменения URL без кодирования запятых\n    const path = window.location.pathname;\n    const newUrl = `${path}?filter=${filters.join(',')}`;\n    window.history.pushState({}, '', newUrl);\n    \n    // Принудительно обновляем React Router\n    window.dispatchEvent(new Event('popstate'));\n  }, []);\n\n  // Обработка изменений URL\n  useEffect(() => {\n    if (!window.places?.length) return;\n\n    // Получаем фильтры из URL\n    const filtersFromUrl = searchParams.get('filter');\n    \n    // Если URL пустой, сбрасываем все фильтры\n    if (!filtersFromUrl) {\n      window.filterStates.clear();\n      if (activeFilters.length > 0) {  // Только если есть активные фильтры\n        onFilterChange([]);\n      }\n      return;\n    }\n\n    // Получаем список фильтров из URL\n    const requestedFilters = filtersFromUrl.split(',').filter(Boolean);\n    \n    // Проверяем, все ли фильтры валидны\n    const validFilters = getValidFilters(requestedFilters);\n    \n    // Если есть невалидные фильтры, обновляем URL\n    if (validFilters.join(',') !== requestedFilters.join(',')) {\n      if (validFilters.length > 0) {\n        setFiltersInUrl(validFilters);\n      } else {\n        setFiltersInUrl(null);\n      }\n      \n      // Останавливаем выполнение, т.к. изменение URL вызовет повторный запуск useEffect\n      return;\n    }\n\n    // Проверяем, изменились ли фильтры\n    const currentActiveFiltersStr = activeFilters.sort().join(',');\n    const newValidFiltersStr = validFilters.sort().join(',');\n    \n    // Обновляем UI-состояние\n    window.filterStates.clear();\n    validFilters.forEach(filter => {\n      window.filterStates.set(filter, true);\n    });\n\n    // Вызываем коллбэк только если фильтры изменились\n    if (currentActiveFiltersStr !== newValidFiltersStr) {\n      onFilterChange(validFilters);\n    }\n  }, [searchParams, onFilterChange, getValidFilters, setFiltersInUrl, activeFilters]);\n\n  // Обработка клика по фильтру\n  const toggleFilter = useCallback((filter: string) => {\n    if (!window.places?.length) return;\n    \n    // Получаем текущие фильтры из URL\n    const urlFilter = searchParams.get('filter') || '';\n    const currentFilters = urlFilter ? urlFilter.split(',').filter(Boolean) : [];\n    const isActive = currentFilters.includes(filter);\n    \n    if (isActive) {\n      // Удаляем фильтр из списка\n      const newFilters = currentFilters.filter(f => f !== filter);\n      \n      // Обновляем UI-состояние\n      window.filterStates.delete(filter);\n      \n      // Проверяем, изменились ли фильтры\n      if (newFilters.join(',') !== currentFilters.join(',')) {\n        // Обновляем URL\n        if (newFilters.length > 0) {\n          setFiltersInUrl(newFilters);\n        } else {\n          setFiltersInUrl(null);\n        }\n      }\n    } else {\n      // Добавляем фильтр, только если у него есть места (счетчик > 0)\n      if (filterCounts[filter] && filterCounts[filter] > 0) {\n        // Проверяем, будет ли фильтр валидным при добавлении\n        const newFilters = [...currentFilters, filter];\n        const validFilters = getValidFilters(newFilters);\n        \n        // Добавляем фильтр только если он валиден в контексте текущих фильтров\n        if (validFilters.includes(filter)) {\n          // Обновляем UI-состояние\n          window.filterStates.set(filter, true);\n          \n          // Проверяем, изменились ли фильтры\n          if (validFilters.join(',') !== currentFilters.join(',')) {\n            // Обновляем URL\n            setFiltersInUrl(validFilters);\n          }\n        }\n      }\n    }\n  }, [searchParams, filterCounts, getValidFilters, setFiltersInUrl]);\n\n  // Функция для полного сброса фильтров\n  const resetFilters = useCallback(() => {\n    // Полностью очищаем состояние\n    window.filterStates.clear();\n    \n    // Очищаем URL\n    setFiltersInUrl(null);\n  }, [setFiltersInUrl]);\n\n  return {\n    toggleFilter,\n    isFilterAvailable: useCallback((filter: string) => {\n      // Если фильтр уже активен, он доступен\n      if (activeFilters.includes(filter)) {\n        return true;\n      }\n      \n      // Иначе проверяем, есть ли для него места\n      return (filterCounts[filter] || 0) > 0;\n    }, [activeFilters]),\n    resetFilters\n  };\n};\n\n// Добавляем типы для window\ndeclare global {\n  interface Window {\n    filterStates: Map<string, boolean>;\n    places: Place[];\n  }\n}\n\nexport default useUrlFilters; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}