{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useCallback } from 'react';\nimport { useSearchParams } from 'react-router-dom';\n// Глобальная Map для хранения состояния фильтров в UI\nif (!window.filterStates) {\n  window.filterStates = new Map();\n}\nexport const useUrlFilters = (activeFilters, onFilterChange, filterCounts) => {\n  _s();\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  // Функция для проверки валидности фильтров\n  const getValidFilters = useCallback(currentFilters => {\n    var _window$places;\n    if (!((_window$places = window.places) !== null && _window$places !== void 0 && _window$places.length)) return [];\n\n    // Если нет фильтров, то возвращаем пустой массив\n    if (!currentFilters.length) return [];\n\n    // Создаем результирующий массив валидных фильтров\n    const validFilters = [];\n\n    // Постепенно фильтруем места, применяя каждый фильтр последовательно\n    let filteredPlaces = [...window.places];\n\n    // Проверяем каждый фильтр последовательно\n    for (const filter of currentFilters) {\n      // Получаем места, соответствующие текущему фильтру из уже отфильтрованных\n      const placesWithFilter = filteredPlaces.filter(place => place.attributes.includes(filter));\n\n      // Если есть хотя бы одно место с этим фильтром, считаем его валидным\n      if (placesWithFilter.length > 0) {\n        validFilters.push(filter);\n        filteredPlaces = placesWithFilter; // Обновляем список мест для следующего фильтра\n      }\n    }\n    return validFilters;\n  }, []);\n\n  // Функция для прямого установления URL с некодированными запятыми\n  const setFiltersInUrl = useCallback(filters => {\n    if (!filters || filters.length === 0) {\n      // Удаляем параметр filter из URL\n      const path = window.location.pathname;\n      window.history.pushState({}, '', path);\n\n      // Принудительно обновляем React Router\n      window.dispatchEvent(new Event('popstate'));\n      return;\n    }\n\n    // Используем history API для прямого изменения URL без кодирования запятых\n    const path = window.location.pathname;\n    const newUrl = `${path}?filter=${filters.join(',')}`;\n    window.history.pushState({}, '', newUrl);\n\n    // Принудительно обновляем React Router\n    window.dispatchEvent(new Event('popstate'));\n  }, []);\n\n  // Обработка изменений URL\n  useEffect(() => {\n    var _window$places2;\n    if (!((_window$places2 = window.places) !== null && _window$places2 !== void 0 && _window$places2.length)) return;\n\n    // Получаем фильтры из URL\n    const filtersFromUrl = searchParams.get('filter');\n\n    // Если URL пустой, сбрасываем все фильтры\n    if (!filtersFromUrl) {\n      window.filterStates.clear();\n      if (activeFilters.length > 0) {\n        // Только если есть активные фильтры\n        onFilterChange([]);\n      }\n      return;\n    }\n\n    // Получаем список фильтров из URL\n    const requestedFilters = filtersFromUrl.split(',').filter(Boolean);\n\n    // Проверяем, все ли фильтры валидны\n    const validFilters = getValidFilters(requestedFilters);\n\n    // Если есть невалидные фильтры, обновляем URL\n    if (validFilters.join(',') !== requestedFilters.join(',')) {\n      if (validFilters.length > 0) {\n        setFiltersInUrl(validFilters);\n      } else {\n        setFiltersInUrl(null);\n      }\n\n      // Останавливаем выполнение, т.к. изменение URL вызовет повторный запуск useEffect\n      return;\n    }\n\n    // Проверяем, изменились ли фильтры\n    const currentActiveFiltersStr = activeFilters.sort().join(',');\n    const newValidFiltersStr = validFilters.sort().join(',');\n\n    // Обновляем UI-состояние\n    window.filterStates.clear();\n    validFilters.forEach(filter => {\n      window.filterStates.set(filter, true);\n    });\n\n    // Вызываем коллбэк только если фильтры изменились\n    if (currentActiveFiltersStr !== newValidFiltersStr) {\n      onFilterChange(validFilters);\n    }\n  }, [searchParams, onFilterChange, getValidFilters, setFiltersInUrl, activeFilters]);\n\n  // Обработка клика по фильтру\n  const toggleFilter = useCallback(filter => {\n    var _window$places3;\n    if (!((_window$places3 = window.places) !== null && _window$places3 !== void 0 && _window$places3.length)) return;\n\n    // Получаем текущие фильтры из URL\n    const urlFilter = searchParams.get('filter') || '';\n    const currentFilters = urlFilter ? urlFilter.split(',').filter(Boolean) : [];\n    const isActive = currentFilters.includes(filter);\n    if (isActive) {\n      // Удаляем фильтр из списка\n      const newFilters = currentFilters.filter(f => f !== filter);\n\n      // Обновляем UI-состояние\n      window.filterStates.delete(filter);\n\n      // Проверяем, изменились ли фильтры\n      if (newFilters.join(',') !== currentFilters.join(',')) {\n        // Обновляем URL\n        if (newFilters.length > 0) {\n          setFiltersInUrl(newFilters);\n        } else {\n          setFiltersInUrl(null);\n        }\n      }\n    } else {\n      // Добавляем фильтр, только если у него есть места (счетчик > 0)\n      if (filterCounts[filter] && filterCounts[filter] > 0) {\n        // Проверяем, будет ли фильтр валидным при добавлении\n        const newFilters = [...currentFilters, filter];\n        const validFilters = getValidFilters(newFilters);\n\n        // Добавляем фильтр только если он валиден в контексте текущих фильтров\n        if (validFilters.includes(filter)) {\n          // Обновляем UI-состояние\n          window.filterStates.set(filter, true);\n\n          // Проверяем, изменились ли фильтры\n          if (validFilters.join(',') !== currentFilters.join(',')) {\n            // Обновляем URL\n            setFiltersInUrl(validFilters);\n          }\n        }\n      }\n    }\n  }, [searchParams, filterCounts, getValidFilters, setFiltersInUrl]);\n\n  // Функция для полного сброса фильтров\n  const resetFilters = useCallback(() => {\n    // Полностью очищаем состояние\n    window.filterStates.clear();\n\n    // Очищаем URL\n    setFiltersInUrl(null);\n  }, [setFiltersInUrl]);\n  return {\n    toggleFilter,\n    isFilterAvailable: useCallback(filter => {\n      // Если фильтр уже активен, он доступен\n      if (activeFilters.includes(filter)) {\n        return true;\n      }\n\n      // Иначе проверяем, есть ли для него места\n      return (filterCounts[filter] || 0) > 0;\n    }, [activeFilters]),\n    resetFilters\n  };\n};\n\n// Добавляем типы для window\n_s(useUrlFilters, \"4tAkMnKPyF2cp2q+myn3VbnRdLI=\", false, function () {\n  return [useSearchParams];\n});\nexport default useUrlFilters;","map":{"version":3,"names":["useEffect","useCallback","useSearchParams","window","filterStates","Map","useUrlFilters","activeFilters","onFilterChange","filterCounts","_s","searchParams","setSearchParams","getValidFilters","currentFilters","_window$places","places","length","validFilters","filteredPlaces","filter","placesWithFilter","place","attributes","includes","push","setFiltersInUrl","filters","path","location","pathname","history","pushState","dispatchEvent","Event","newUrl","join","_window$places2","filtersFromUrl","get","clear","requestedFilters","split","Boolean","currentActiveFiltersStr","sort","newValidFiltersStr","forEach","set","toggleFilter","_window$places3","urlFilter","isActive","newFilters","f","delete","resetFilters","isFilterAvailable"],"sources":["/Users/borvel/Documents/GitHub/places-app/src/hooks/useUrlFilters.ts"],"sourcesContent":["import { useEffect, useCallback } from 'react';\nimport { useSearchParams } from 'react-router-dom';\nimport { Place } from '../types/places';\n\n// Глобальная Map для хранения состояния фильтров в UI\nif (!window.filterStates) {\n  window.filterStates = new Map<string, boolean>();\n}\n\nexport const useUrlFilters = (\n  activeFilters: string[],\n  onFilterChange: (filters: string[]) => void,\n  filterCounts: Record<string, number>\n) => {\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  // Функция для проверки валидности фильтров\n  const getValidFilters = useCallback((currentFilters: string[]) => {\n    if (!window.places?.length) return [];\n    \n    // Если нет фильтров, то возвращаем пустой массив\n    if (!currentFilters.length) return [];\n    \n    // Создаем результирующий массив валидных фильтров\n    const validFilters: string[] = [];\n    \n    // Постепенно фильтруем места, применяя каждый фильтр последовательно\n    let filteredPlaces = [...window.places];\n    \n    // Проверяем каждый фильтр последовательно\n    for (const filter of currentFilters) {\n      // Получаем места, соответствующие текущему фильтру из уже отфильтрованных\n      const placesWithFilter = filteredPlaces.filter(place => \n        place.attributes.includes(filter)\n      );\n      \n      // Если есть хотя бы одно место с этим фильтром, считаем его валидным\n      if (placesWithFilter.length > 0) {\n        validFilters.push(filter);\n        filteredPlaces = placesWithFilter; // Обновляем список мест для следующего фильтра\n      }\n    }\n    \n    return validFilters;\n  }, []);\n\n  // Функция для прямого установления URL с некодированными запятыми\n  const setFiltersInUrl = useCallback((filters: string[] | null) => {\n    if (!filters || filters.length === 0) {\n      // Удаляем параметр filter из URL\n      const path = window.location.pathname;\n      window.history.pushState({}, '', path);\n      \n      // Принудительно обновляем React Router\n      window.dispatchEvent(new Event('popstate'));\n      return;\n    }\n\n    // Используем history API для прямого изменения URL без кодирования запятых\n    const path = window.location.pathname;\n    const newUrl = `${path}?filter=${filters.join(',')}`;\n    window.history.pushState({}, '', newUrl);\n    \n    // Принудительно обновляем React Router\n    window.dispatchEvent(new Event('popstate'));\n  }, []);\n\n  // Обработка изменений URL\n  useEffect(() => {\n    if (!window.places?.length) return;\n\n    // Получаем фильтры из URL\n    const filtersFromUrl = searchParams.get('filter');\n    \n    // Если URL пустой, сбрасываем все фильтры\n    if (!filtersFromUrl) {\n      window.filterStates.clear();\n      if (activeFilters.length > 0) {  // Только если есть активные фильтры\n        onFilterChange([]);\n      }\n      return;\n    }\n\n    // Получаем список фильтров из URL\n    const requestedFilters = filtersFromUrl.split(',').filter(Boolean);\n    \n    // Проверяем, все ли фильтры валидны\n    const validFilters = getValidFilters(requestedFilters);\n    \n    // Если есть невалидные фильтры, обновляем URL\n    if (validFilters.join(',') !== requestedFilters.join(',')) {\n      if (validFilters.length > 0) {\n        setFiltersInUrl(validFilters);\n      } else {\n        setFiltersInUrl(null);\n      }\n      \n      // Останавливаем выполнение, т.к. изменение URL вызовет повторный запуск useEffect\n      return;\n    }\n\n    // Проверяем, изменились ли фильтры\n    const currentActiveFiltersStr = activeFilters.sort().join(',');\n    const newValidFiltersStr = validFilters.sort().join(',');\n    \n    // Обновляем UI-состояние\n    window.filterStates.clear();\n    validFilters.forEach(filter => {\n      window.filterStates.set(filter, true);\n    });\n\n    // Вызываем коллбэк только если фильтры изменились\n    if (currentActiveFiltersStr !== newValidFiltersStr) {\n      onFilterChange(validFilters);\n    }\n  }, [searchParams, onFilterChange, getValidFilters, setFiltersInUrl, activeFilters]);\n\n  // Обработка клика по фильтру\n  const toggleFilter = useCallback((filter: string) => {\n    if (!window.places?.length) return;\n    \n    // Получаем текущие фильтры из URL\n    const urlFilter = searchParams.get('filter') || '';\n    const currentFilters = urlFilter ? urlFilter.split(',').filter(Boolean) : [];\n    const isActive = currentFilters.includes(filter);\n    \n    if (isActive) {\n      // Удаляем фильтр из списка\n      const newFilters = currentFilters.filter(f => f !== filter);\n      \n      // Обновляем UI-состояние\n      window.filterStates.delete(filter);\n      \n      // Проверяем, изменились ли фильтры\n      if (newFilters.join(',') !== currentFilters.join(',')) {\n        // Обновляем URL\n        if (newFilters.length > 0) {\n          setFiltersInUrl(newFilters);\n        } else {\n          setFiltersInUrl(null);\n        }\n      }\n    } else {\n      // Добавляем фильтр, только если у него есть места (счетчик > 0)\n      if (filterCounts[filter] && filterCounts[filter] > 0) {\n        // Проверяем, будет ли фильтр валидным при добавлении\n        const newFilters = [...currentFilters, filter];\n        const validFilters = getValidFilters(newFilters);\n        \n        // Добавляем фильтр только если он валиден в контексте текущих фильтров\n        if (validFilters.includes(filter)) {\n          // Обновляем UI-состояние\n          window.filterStates.set(filter, true);\n          \n          // Проверяем, изменились ли фильтры\n          if (validFilters.join(',') !== currentFilters.join(',')) {\n            // Обновляем URL\n            setFiltersInUrl(validFilters);\n          }\n        }\n      }\n    }\n  }, [searchParams, filterCounts, getValidFilters, setFiltersInUrl]);\n\n  // Функция для полного сброса фильтров\n  const resetFilters = useCallback(() => {\n    // Полностью очищаем состояние\n    window.filterStates.clear();\n    \n    // Очищаем URL\n    setFiltersInUrl(null);\n  }, [setFiltersInUrl]);\n\n  return {\n    toggleFilter,\n    isFilterAvailable: useCallback((filter: string) => {\n      // Если фильтр уже активен, он доступен\n      if (activeFilters.includes(filter)) {\n        return true;\n      }\n      \n      // Иначе проверяем, есть ли для него места\n      return (filterCounts[filter] || 0) > 0;\n    }, [activeFilters]),\n    resetFilters\n  };\n};\n\n// Добавляем типы для window\ndeclare global {\n  interface Window {\n    filterStates: Map<string, boolean>;\n    places: Place[];\n  }\n}\n\nexport default useUrlFilters; "],"mappings":";AAAA,SAASA,SAAS,EAAEC,WAAW,QAAQ,OAAO;AAC9C,SAASC,eAAe,QAAQ,kBAAkB;AAGlD;AACA,IAAI,CAACC,MAAM,CAACC,YAAY,EAAE;EACxBD,MAAM,CAACC,YAAY,GAAG,IAAIC,GAAG,CAAkB,CAAC;AAClD;AAEA,OAAO,MAAMC,aAAa,GAAGA,CAC3BC,aAAuB,EACvBC,cAA2C,EAC3CC,YAAoC,KACjC;EAAAC,EAAA;EACH,MAAM,CAACC,YAAY,EAAEC,eAAe,CAAC,GAAGV,eAAe,CAAC,CAAC;;EAEzD;EACA,MAAMW,eAAe,GAAGZ,WAAW,CAAEa,cAAwB,IAAK;IAAA,IAAAC,cAAA;IAChE,IAAI,GAAAA,cAAA,GAACZ,MAAM,CAACa,MAAM,cAAAD,cAAA,eAAbA,cAAA,CAAeE,MAAM,GAAE,OAAO,EAAE;;IAErC;IACA,IAAI,CAACH,cAAc,CAACG,MAAM,EAAE,OAAO,EAAE;;IAErC;IACA,MAAMC,YAAsB,GAAG,EAAE;;IAEjC;IACA,IAAIC,cAAc,GAAG,CAAC,GAAGhB,MAAM,CAACa,MAAM,CAAC;;IAEvC;IACA,KAAK,MAAMI,MAAM,IAAIN,cAAc,EAAE;MACnC;MACA,MAAMO,gBAAgB,GAAGF,cAAc,CAACC,MAAM,CAACE,KAAK,IAClDA,KAAK,CAACC,UAAU,CAACC,QAAQ,CAACJ,MAAM,CAClC,CAAC;;MAED;MACA,IAAIC,gBAAgB,CAACJ,MAAM,GAAG,CAAC,EAAE;QAC/BC,YAAY,CAACO,IAAI,CAACL,MAAM,CAAC;QACzBD,cAAc,GAAGE,gBAAgB,CAAC,CAAC;MACrC;IACF;IAEA,OAAOH,YAAY;EACrB,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMQ,eAAe,GAAGzB,WAAW,CAAE0B,OAAwB,IAAK;IAChE,IAAI,CAACA,OAAO,IAAIA,OAAO,CAACV,MAAM,KAAK,CAAC,EAAE;MACpC;MACA,MAAMW,IAAI,GAAGzB,MAAM,CAAC0B,QAAQ,CAACC,QAAQ;MACrC3B,MAAM,CAAC4B,OAAO,CAACC,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,EAAEJ,IAAI,CAAC;;MAEtC;MACAzB,MAAM,CAAC8B,aAAa,CAAC,IAAIC,KAAK,CAAC,UAAU,CAAC,CAAC;MAC3C;IACF;;IAEA;IACA,MAAMN,IAAI,GAAGzB,MAAM,CAAC0B,QAAQ,CAACC,QAAQ;IACrC,MAAMK,MAAM,GAAG,GAAGP,IAAI,WAAWD,OAAO,CAACS,IAAI,CAAC,GAAG,CAAC,EAAE;IACpDjC,MAAM,CAAC4B,OAAO,CAACC,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,EAAEG,MAAM,CAAC;;IAExC;IACAhC,MAAM,CAAC8B,aAAa,CAAC,IAAIC,KAAK,CAAC,UAAU,CAAC,CAAC;EAC7C,CAAC,EAAE,EAAE,CAAC;;EAEN;EACAlC,SAAS,CAAC,MAAM;IAAA,IAAAqC,eAAA;IACd,IAAI,GAAAA,eAAA,GAAClC,MAAM,CAACa,MAAM,cAAAqB,eAAA,eAAbA,eAAA,CAAepB,MAAM,GAAE;;IAE5B;IACA,MAAMqB,cAAc,GAAG3B,YAAY,CAAC4B,GAAG,CAAC,QAAQ,CAAC;;IAEjD;IACA,IAAI,CAACD,cAAc,EAAE;MACnBnC,MAAM,CAACC,YAAY,CAACoC,KAAK,CAAC,CAAC;MAC3B,IAAIjC,aAAa,CAACU,MAAM,GAAG,CAAC,EAAE;QAAG;QAC/BT,cAAc,CAAC,EAAE,CAAC;MACpB;MACA;IACF;;IAEA;IACA,MAAMiC,gBAAgB,GAAGH,cAAc,CAACI,KAAK,CAAC,GAAG,CAAC,CAACtB,MAAM,CAACuB,OAAO,CAAC;;IAElE;IACA,MAAMzB,YAAY,GAAGL,eAAe,CAAC4B,gBAAgB,CAAC;;IAEtD;IACA,IAAIvB,YAAY,CAACkB,IAAI,CAAC,GAAG,CAAC,KAAKK,gBAAgB,CAACL,IAAI,CAAC,GAAG,CAAC,EAAE;MACzD,IAAIlB,YAAY,CAACD,MAAM,GAAG,CAAC,EAAE;QAC3BS,eAAe,CAACR,YAAY,CAAC;MAC/B,CAAC,MAAM;QACLQ,eAAe,CAAC,IAAI,CAAC;MACvB;;MAEA;MACA;IACF;;IAEA;IACA,MAAMkB,uBAAuB,GAAGrC,aAAa,CAACsC,IAAI,CAAC,CAAC,CAACT,IAAI,CAAC,GAAG,CAAC;IAC9D,MAAMU,kBAAkB,GAAG5B,YAAY,CAAC2B,IAAI,CAAC,CAAC,CAACT,IAAI,CAAC,GAAG,CAAC;;IAExD;IACAjC,MAAM,CAACC,YAAY,CAACoC,KAAK,CAAC,CAAC;IAC3BtB,YAAY,CAAC6B,OAAO,CAAC3B,MAAM,IAAI;MAC7BjB,MAAM,CAACC,YAAY,CAAC4C,GAAG,CAAC5B,MAAM,EAAE,IAAI,CAAC;IACvC,CAAC,CAAC;;IAEF;IACA,IAAIwB,uBAAuB,KAAKE,kBAAkB,EAAE;MAClDtC,cAAc,CAACU,YAAY,CAAC;IAC9B;EACF,CAAC,EAAE,CAACP,YAAY,EAAEH,cAAc,EAAEK,eAAe,EAAEa,eAAe,EAAEnB,aAAa,CAAC,CAAC;;EAEnF;EACA,MAAM0C,YAAY,GAAGhD,WAAW,CAAEmB,MAAc,IAAK;IAAA,IAAA8B,eAAA;IACnD,IAAI,GAAAA,eAAA,GAAC/C,MAAM,CAACa,MAAM,cAAAkC,eAAA,eAAbA,eAAA,CAAejC,MAAM,GAAE;;IAE5B;IACA,MAAMkC,SAAS,GAAGxC,YAAY,CAAC4B,GAAG,CAAC,QAAQ,CAAC,IAAI,EAAE;IAClD,MAAMzB,cAAc,GAAGqC,SAAS,GAAGA,SAAS,CAACT,KAAK,CAAC,GAAG,CAAC,CAACtB,MAAM,CAACuB,OAAO,CAAC,GAAG,EAAE;IAC5E,MAAMS,QAAQ,GAAGtC,cAAc,CAACU,QAAQ,CAACJ,MAAM,CAAC;IAEhD,IAAIgC,QAAQ,EAAE;MACZ;MACA,MAAMC,UAAU,GAAGvC,cAAc,CAACM,MAAM,CAACkC,CAAC,IAAIA,CAAC,KAAKlC,MAAM,CAAC;;MAE3D;MACAjB,MAAM,CAACC,YAAY,CAACmD,MAAM,CAACnC,MAAM,CAAC;;MAElC;MACA,IAAIiC,UAAU,CAACjB,IAAI,CAAC,GAAG,CAAC,KAAKtB,cAAc,CAACsB,IAAI,CAAC,GAAG,CAAC,EAAE;QACrD;QACA,IAAIiB,UAAU,CAACpC,MAAM,GAAG,CAAC,EAAE;UACzBS,eAAe,CAAC2B,UAAU,CAAC;QAC7B,CAAC,MAAM;UACL3B,eAAe,CAAC,IAAI,CAAC;QACvB;MACF;IACF,CAAC,MAAM;MACL;MACA,IAAIjB,YAAY,CAACW,MAAM,CAAC,IAAIX,YAAY,CAACW,MAAM,CAAC,GAAG,CAAC,EAAE;QACpD;QACA,MAAMiC,UAAU,GAAG,CAAC,GAAGvC,cAAc,EAAEM,MAAM,CAAC;QAC9C,MAAMF,YAAY,GAAGL,eAAe,CAACwC,UAAU,CAAC;;QAEhD;QACA,IAAInC,YAAY,CAACM,QAAQ,CAACJ,MAAM,CAAC,EAAE;UACjC;UACAjB,MAAM,CAACC,YAAY,CAAC4C,GAAG,CAAC5B,MAAM,EAAE,IAAI,CAAC;;UAErC;UACA,IAAIF,YAAY,CAACkB,IAAI,CAAC,GAAG,CAAC,KAAKtB,cAAc,CAACsB,IAAI,CAAC,GAAG,CAAC,EAAE;YACvD;YACAV,eAAe,CAACR,YAAY,CAAC;UAC/B;QACF;MACF;IACF;EACF,CAAC,EAAE,CAACP,YAAY,EAAEF,YAAY,EAAEI,eAAe,EAAEa,eAAe,CAAC,CAAC;;EAElE;EACA,MAAM8B,YAAY,GAAGvD,WAAW,CAAC,MAAM;IACrC;IACAE,MAAM,CAACC,YAAY,CAACoC,KAAK,CAAC,CAAC;;IAE3B;IACAd,eAAe,CAAC,IAAI,CAAC;EACvB,CAAC,EAAE,CAACA,eAAe,CAAC,CAAC;EAErB,OAAO;IACLuB,YAAY;IACZQ,iBAAiB,EAAExD,WAAW,CAAEmB,MAAc,IAAK;MACjD;MACA,IAAIb,aAAa,CAACiB,QAAQ,CAACJ,MAAM,CAAC,EAAE;QAClC,OAAO,IAAI;MACb;;MAEA;MACA,OAAO,CAACX,YAAY,CAACW,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;IACxC,CAAC,EAAE,CAACb,aAAa,CAAC,CAAC;IACnBiD;EACF,CAAC;AACH,CAAC;;AAED;AAAA9C,EAAA,CAnLaJ,aAAa;EAAA,QAKgBJ,eAAe;AAAA;AAsLzD,eAAeI,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}