{"ast":null,"code":"var _jsxFileName = \"/Users/borvel/Documents/GitHub/places-app/src/components/Map/Map.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useCallback, useMemo } from 'react';\nimport L from 'leaflet';\nimport 'leaflet/dist/leaflet.css';\nimport 'leaflet.markercluster';\nimport 'leaflet.markercluster/dist/MarkerCluster.css';\nimport 'leaflet.markercluster/dist/MarkerCluster.Default.css';\nimport { styled } from 'styled-components';\n\n// Fix for default icon\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\ndelete L.Icon.Default.prototype._getIconUrl;\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\n  iconUrl: require('leaflet/dist/images/marker-icon.png'),\n  shadowUrl: require('leaflet/dist/images/marker-shadow.png')\n});\nconst MapContainer = styled.div`\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 1;\n  will-change: transform;\n  transform: translateZ(0);\n  backface-visibility: hidden;\n  perspective: 1000px;\n`;\n\n// Расширяем интерфейс MapOptions для поддержки дополнительных свойств\n_c = MapContainer;\nconst createPopupContent = place => `\n  <div class=\"place-card\">\n    <img src=\"${place.image}\" alt=\"${place.name}\" class=\"place-image\" style=\"width: 100%; height: 200px; object-fit: cover;\" />\n    <div class=\"place-content\" style=\"padding: 15px;\">\n      <h3 style=\"margin: 0; font-size: 18px;\">${place.name}</h3>\n      <p style=\"margin: 10px 0; font-size: 14px;\">${place.description}</p>\n      <div class=\"place-links-social\" style=\"margin-top: 10px;\">\n        ${place.instagram ? `<a href=\"${place.instagram}\" target=\"_blank\"><img src=\"/data/images/instagram.svg\" alt=\"Instagram\" style=\"width: 27px; height: 27px;\" /></a>` : ''}\n        ${place.maps_url ? `<a href=\"${place.maps_url}\" target=\"_blank\"><img src=\"/data/images/google.svg\" alt=\"Google Maps\" style=\"width: 27px; height: 27px;\" /></a>` : ''}\n      </div>\n    </div>\n  </div>\n`;\nexport const Map = ({\n  places,\n  config,\n  onMarkerClick,\n  selectedPlace,\n  mapRef,\n  onPopupClose,\n  onBoundsChange\n}) => {\n  _s();\n  const markersRef = useRef(null);\n  const activeMarkerRef = useRef(null);\n  const containerRef = useRef(null);\n  const mobilePopupRef = useRef(null);\n  // Флаг для отслеживания программного закрытия попапа\n  const isProgrammaticClose = useRef(false);\n  // Флаг для отслеживания первой установки границ\n  const isInitialBoundsSet = useRef(false);\n  // Храним ссылку на функцию обратного вызова на верхнем уровне\n  const onBoundsChangeRef = useRef(onBoundsChange);\n  // Ссылка для хранения таймаута updateLabelsVisibility\n  const updateTimeoutRef = useRef(null);\n  // Ссылка для хранения таймаута обновления границ\n  const boundsTimeoutRef = useRef(null);\n  // Храним ссылку на массив маркеров для оптимизации\n  const markersArrayRef = useRef([]);\n  // Храним результаты предыдущего расчёта видимости для предотвращения ненужных обновлений\n  const lastVisibilityStateRef = useRef({});\n  // Счётчик обновлений для оптимизации\n  const updateCountRef = useRef(0);\n\n  // Обновляем ссылку при изменении функции\n  useEffect(() => {\n    onBoundsChangeRef.current = onBoundsChange;\n  }, [onBoundsChange]);\n\n  // Мемоизируем создание иконок для предотвращения повторных созданий\n  const defaultIcon = useMemo(() => {\n    return L.divIcon({\n      className: 'marker-default',\n      iconSize: [30, 30],\n      iconAnchor: [15, 15],\n      html: '<div></div>'\n    });\n  }, []);\n  const customIcon = useMemo(() => {\n    return L.divIcon({\n      className: 'marker-active',\n      iconSize: [30, 40],\n      iconAnchor: [15, 40],\n      popupAnchor: [0, -40],\n      html: '<div></div>'\n    });\n  }, []);\n\n  // Создаем мобильный попап\n  useEffect(() => {\n    if (!mobilePopupRef.current) {\n      const popupDiv = document.createElement('div');\n      popupDiv.className = 'map-popup-mobile';\n      document.body.appendChild(popupDiv);\n      mobilePopupRef.current = popupDiv;\n      return () => {\n        document.body.removeChild(popupDiv);\n        mobilePopupRef.current = null;\n      };\n    }\n  }, []);\n  const showMobilePopup = useCallback(place => {\n    if (!mobilePopupRef.current) return;\n    const popupContent = `\n      <div class=\"place-card\">\n        <img src=\"${place.image}\" alt=\"${place.name}\" class=\"place-image\" />\n        <div class=\"place-content\">\n          <h3>${place.name}</h3>\n          <p>${place.description}</p>\n          <div class=\"place-links-social\">\n            ${place.instagram ? `<a href=\"${place.instagram}\" target=\"_blank\"><img src=\"/data/images/instagram.svg\" alt=\"Instagram\" /></a>` : ''}\n            ${place.maps_url ? `<a href=\"${place.maps_url}\" target=\"_blank\"><img src=\"/data/images/google.svg\" alt=\"Google Maps\" /></a>` : ''}\n          </div>\n        </div>\n        <button class=\"close-btn-mobile\">×</button>\n      </div>\n    `;\n    mobilePopupRef.current.innerHTML = popupContent;\n    mobilePopupRef.current.classList.add('active');\n    const closeBtn = mobilePopupRef.current.querySelector('.close-btn-mobile');\n    if (closeBtn) {\n      closeBtn.addEventListener('click', () => {\n        if (mobilePopupRef.current) {\n          mobilePopupRef.current.classList.remove('active');\n          if (activeMarkerRef.current) {\n            activeMarkerRef.current.setIcon(defaultIcon);\n            activeMarkerRef.current = null;\n          }\n\n          // Сообщаем, что попап закрыт, чтобы сбросить selectedPlace\n          if (onPopupClose) {\n            onPopupClose();\n          }\n        }\n      });\n    }\n  }, [onPopupClose, defaultIcon]);\n  const createMarkerClusterGroup = useCallback(() => {\n    return L.markerClusterGroup({\n      iconCreateFunction: cluster => {\n        const count = cluster.getChildCount();\n        return L.divIcon({\n          html: `<div class=\"cluster-icon\">${count}</div>`,\n          className: 'marker-cluster',\n          iconSize: L.point(40, 40)\n        });\n      },\n      disableClusteringAtZoom: config.mapSettings.clusterSettings.disableClusteringAtZoom,\n      spiderfyOnMaxZoom: false,\n      maxClusterRadius: config.mapSettings.clusterSettings.maxClusterRadius,\n      zoomToBoundsOnClick: false,\n      showCoverageOnHover: false,\n      animate: true,\n      animateAddingMarkers: false\n    });\n  }, [config.mapSettings.clusterSettings]);\n\n  // Функция для проверки наложения меток\n  const shouldShowLabel = useCallback((marker, visibleMarkers) => {\n    if (!mapRef.current) return false;\n\n    // Одиночные метки всегда показываем\n    if (visibleMarkers.length <= 1) return true;\n    const markerPoint = mapRef.current.latLngToContainerPoint(marker.getLatLng());\n    if (!markerPoint) return false;\n\n    // Минимальное расстояние между метками в пикселях\n    const minDistance = 100;\n\n    // Проверяем расстояние до других видимых меток\n    for (const otherMarker of visibleMarkers) {\n      if (marker === otherMarker) continue;\n      const otherPoint = mapRef.current.latLngToContainerPoint(otherMarker.getLatLng());\n      if (!otherPoint) continue;\n      const distance = markerPoint.distanceTo(otherPoint);\n      if (distance < minDistance) {\n        // Если метки слишком близко, показываем только ту, что ближе к центру экрана\n        const center = mapRef.current.getCenter();\n        if (!center) continue;\n        const centerPoint = mapRef.current.latLngToContainerPoint(center);\n        if (!centerPoint) continue;\n        const distToCenter = markerPoint.distanceTo(centerPoint);\n        const otherDistToCenter = otherPoint.distanceTo(centerPoint);\n\n        // Если эта метка дальше от центра, скрываем её\n        if (distToCenter > otherDistToCenter) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }, [mapRef]);\n\n  // Создаем дебаунсированную функцию обновления видимости меток\n  const updateLabelsVisibility = useCallback(() => {\n    // Отменяем предыдущий таймаут, если он есть\n    if (updateTimeoutRef.current) {\n      window.clearTimeout(updateTimeoutRef.current);\n    }\n\n    // Счетчик обновлений (избегаем слишком частых обновлений)\n    updateCountRef.current++;\n    const currentCount = updateCountRef.current;\n\n    // Устанавливаем новый таймаут с увеличенной задержкой\n    updateTimeoutRef.current = window.setTimeout(() => {\n      // Пропускаем, если выполняется более новое обновление\n      if (currentCount !== updateCountRef.current) return;\n      if (!mapRef.current || !markersRef.current) return;\n      const markers = markersArrayRef.current;\n      if (markers.length === 0) return;\n      const zoom = mapRef.current.getZoom();\n\n      // Для небольшого зума скрываем все названия\n      if (zoom < 14) {\n        // Скрываем только если они были видимы\n        const hasVisibleMarkers = Object.values(lastVisibilityStateRef.current).some(state => state);\n        if (hasVisibleMarkers) {\n          markers.forEach(marker => {\n            const tooltip = marker.getTooltip();\n            if (tooltip) tooltip.setOpacity(0);\n          });\n\n          // Обновляем состояние видимости\n          lastVisibilityStateRef.current = {};\n        }\n        return;\n      }\n\n      // Кэшируем видимые маркеры для уменьшения вычислений\n      const visibleMarkers = [];\n      markers.forEach(marker => {\n        var _markersRef$current;\n        // Проверяем, является ли родитель маркера кластером\n        const parent = (_markersRef$current = markersRef.current) === null || _markersRef$current === void 0 ? void 0 : _markersRef$current.getVisibleParent(marker);\n        if (parent === marker) {\n          visibleMarkers.push(marker);\n        }\n      });\n\n      // Если нет видимых маркеров, пропускаем\n      if (visibleMarkers.length === 0) return;\n\n      // Используем обычный объект для отслеживания изменений видимости\n      const tooltipVisibility = {};\n\n      // Определяем, какие маркеры должны быть видимыми\n      visibleMarkers.forEach(marker => {\n        const markerId = marker._leaflet_id;\n        tooltipVisibility[markerId] = shouldShowLabel(marker, visibleMarkers);\n      });\n\n      // Проверяем, изменилось ли что-то в состоянии видимости\n      let hasChanges = false;\n      for (const markerId in tooltipVisibility) {\n        if (tooltipVisibility[markerId] !== lastVisibilityStateRef.current[markerId]) {\n          hasChanges = true;\n          break;\n        }\n      }\n\n      // Если состояние не изменилось, пропускаем обновления\n      if (!hasChanges) return;\n\n      // Обновляем только маркеры, состояние которых изменилось\n      markers.forEach(marker => {\n        var _tooltip$getElement;\n        const tooltip = marker.getTooltip();\n        if (!tooltip) return;\n\n        // Проверяем, должна ли метка быть видимой\n        const markerId = marker._leaflet_id;\n        const shouldBeVisible = tooltipVisibility[markerId] && visibleMarkers.includes(marker);\n        const isVisible = ((_tooltip$getElement = tooltip.getElement()) === null || _tooltip$getElement === void 0 ? void 0 : _tooltip$getElement.style.opacity) !== '0';\n\n        // Обновляем только если состояние изменилось\n        if (shouldBeVisible !== isVisible) {\n          tooltip.setOpacity(shouldBeVisible ? 1 : 0);\n        }\n      });\n\n      // Сохраняем текущее состояние для следующего сравнения\n      lastVisibilityStateRef.current = {\n        ...tooltipVisibility\n      };\n    }, 200); // Увеличиваем задержку для лучшего дебаунсинга\n  }, [shouldShowLabel, mapRef]);\n  const updateMarkers = useCallback(() => {\n    if (!mapRef.current || !markersRef.current) return;\n\n    // Очищаем все слои, включая предыдущие маркеры\n    markersRef.current.clearLayers();\n\n    // Сбрасываем активный маркер и массив маркеров\n    activeMarkerRef.current = null;\n    markersArrayRef.current = [];\n\n    // Создаем маркеры с tooltips\n    const markers = [];\n    places.forEach(place => {\n      var _markersRef$current2;\n      const marker = L.marker([place.lat, place.lng], {\n        icon: defaultIcon,\n        riseOnHover: true,\n        riseOffset: 250\n      });\n      if (window.innerWidth > 768) {\n        const popup = L.popup({\n          maxWidth: 500,\n          className: 'place-popup',\n          closeButton: true,\n          closeOnClick: false,\n          autoPan: true,\n          autoPanPadding: [50, 50]\n        }).setContent(createPopupContent(place));\n        marker.bindPopup(popup);\n      }\n\n      // Создаем tooltip и делаем его невидимым по умолчанию\n      marker.bindTooltip(place.name, {\n        permanent: true,\n        direction: 'bottom',\n        offset: [0, 5],\n        className: 'place-label',\n        opacity: 0\n      });\n\n      // Добавляем место в данные маркера для доступа в дальнейшем\n      marker.place = place;\n      marker.on('click', () => {\n        var _mapRef$current, _mapRef$current2;\n        // При клике на тот же маркер, отменяем выбор\n        if (activeMarkerRef.current === marker) {\n          marker.setIcon(defaultIcon);\n          if (window.innerWidth > 768) {\n            isProgrammaticClose.current = true;\n            marker.closePopup();\n          }\n          activeMarkerRef.current = null;\n          onMarkerClick(place); // Передаем повторный клик для отмены выбора\n          return;\n        }\n\n        // При клике на другой маркер\n        if (activeMarkerRef.current && activeMarkerRef.current !== marker) {\n          activeMarkerRef.current.setIcon(defaultIcon);\n          if (window.innerWidth > 768) {\n            isProgrammaticClose.current = true;\n            activeMarkerRef.current.closePopup();\n          }\n        }\n        marker.setIcon(customIcon);\n        activeMarkerRef.current = marker;\n\n        // Центрируем карту с проверкой зума\n        const currentZoom = ((_mapRef$current = mapRef.current) === null || _mapRef$current === void 0 ? void 0 : _mapRef$current.getZoom()) || 0;\n        const targetZoom = currentZoom >= 16 ? currentZoom : 16;\n        (_mapRef$current2 = mapRef.current) === null || _mapRef$current2 === void 0 ? void 0 : _mapRef$current2.setView(marker.getLatLng(), targetZoom, {\n          animate: true,\n          duration: 0.5\n        });\n        if (window.innerWidth > 768) {\n          marker.openPopup();\n        } else {\n          showMobilePopup(place);\n        }\n        onMarkerClick(place);\n      });\n      markers.push(marker);\n      (_markersRef$current2 = markersRef.current) === null || _markersRef$current2 === void 0 ? void 0 : _markersRef$current2.addLayer(marker);\n\n      // Устанавливаем активный маркер для выбранного места\n      if (selectedPlace && selectedPlace.name === place.name) {\n        marker.setIcon(customIcon);\n        activeMarkerRef.current = marker;\n        if (window.innerWidth > 768) {\n          marker.openPopup();\n        } else {\n          showMobilePopup(place);\n        }\n      }\n    });\n\n    // Сохраняем ссылку на массив маркеров\n    markersArrayRef.current = markers;\n\n    // Добавляем обработчик клика на кластер\n    markersRef.current.on('clusterclick', e => {\n      const cluster = e.layer;\n      const childMarkers = cluster.getAllChildMarkers();\n      if (childMarkers.length === 1) {\n        childMarkers[0].fire('click');\n      } else {\n        var _mapRef$current3;\n        (_mapRef$current3 = mapRef.current) === null || _mapRef$current3 === void 0 ? void 0 : _mapRef$current3.setView(cluster.getLatLng(), 16, {\n          animate: true\n        });\n      }\n\n      // Обновляем видимость названий после раскрытия кластера с большей задержкой\n      setTimeout(updateLabelsVisibility, 300);\n    });\n\n    // Используем единый обработчик для событий с дебаунсингом\n    const handleMapChange = () => updateLabelsVisibility();\n\n    // События, при которых нужно обновлять видимость названий\n    mapRef.current.on('zoomend', handleMapChange);\n    mapRef.current.on('moveend', handleMapChange);\n    markersRef.current.on('animationend', handleMapChange);\n\n    // Обновляем сразу после создания маркеров\n    setTimeout(updateLabelsVisibility, 100);\n\n    // Очистка обработчиков и таймаутов при размонтировании\n    return () => {\n      if (updateTimeoutRef.current) {\n        window.clearTimeout(updateTimeoutRef.current);\n      }\n      if (mapRef.current) {\n        mapRef.current.off('zoomend', handleMapChange);\n        mapRef.current.off('moveend', handleMapChange);\n      }\n      if (markersRef.current) {\n        markersRef.current.off('animationend', handleMapChange);\n      }\n    };\n  }, [places, selectedPlace, defaultIcon, customIcon, mapRef, onMarkerClick, showMobilePopup, updateLabelsVisibility]);\n  useEffect(() => {\n    if (!containerRef.current || mapRef.current) return;\n    const map = L.map(containerRef.current, {\n      center: config.mapSettings.center,\n      zoom: config.mapSettings.initialZoom,\n      scrollWheelZoom: true,\n      closePopupOnClick: true,\n      tap: false,\n      attributionControl: false,\n      zoomControl: false,\n      maxZoom: config.mapSettings.maxZoom,\n      minZoom: config.mapSettings.initialZoom - 2,\n      bounceAtZoomLimits: false,\n      inertia: false\n    });\n    L.tileLayer(config.mapSettings.tileLayer.url, {\n      attribution: config.mapSettings.tileLayer.attribution,\n      subdomains: config.mapSettings.tileLayer.subdomains,\n      maxZoom: config.mapSettings.maxZoom,\n      minZoom: config.mapSettings.initialZoom - 2,\n      preferCanvas: true\n    }).addTo(map);\n    L.control.attribution({\n      position: 'bottomright',\n      prefix: false\n    }).addTo(map);\n    L.control.zoom({\n      position: 'topright'\n    }).addTo(map);\n    mapRef.current = map;\n    markersRef.current = createMarkerClusterGroup();\n    map.addLayer(markersRef.current);\n\n    // Добавляем глобальный обработчик touchmove для предотвращения скроллинга страницы\n    // при взаимодействии с картой\n    const preventDefaultTouchMoveOnMap = e => {\n      if (e.target && e.target.closest('.leaflet-container')) {\n        e.preventDefault();\n      }\n    };\n\n    // Добавляем обработчик на уровне документа с passive: false,\n    // чтобы иметь возможность вызывать preventDefault()\n    document.addEventListener('touchmove', preventDefaultTouchMoveOnMap, {\n      passive: false\n    });\n\n    // Используем throttling для обработчика изменения размера\n    let resizeTimeout = null;\n    const handleResize = () => {\n      if (resizeTimeout) return;\n      resizeTimeout = window.setTimeout(() => {\n        map.invalidateSize({\n          animate: false,\n          pan: false\n        });\n        resizeTimeout = null;\n      }, 100);\n    };\n    window.addEventListener('resize', handleResize);\n    window.addEventListener('orientationchange', handleResize);\n\n    // Используем явный window.setTimeout для избежания проблем с асинхронностью\n    window.setTimeout(handleResize, 100);\n    return () => {\n      document.removeEventListener('touchmove', preventDefaultTouchMoveOnMap);\n      window.removeEventListener('resize', handleResize);\n      window.removeEventListener('orientationchange', handleResize);\n\n      // Очищаем таймауты\n      if (updateTimeoutRef.current) {\n        window.clearTimeout(updateTimeoutRef.current);\n      }\n      if (resizeTimeout) {\n        window.clearTimeout(resizeTimeout);\n      }\n      map.remove();\n      mapRef.current = null;\n      markersRef.current = null;\n    };\n  }, [config, createMarkerClusterGroup, mapRef]);\n  useEffect(() => {\n    if (mapRef.current && markersRef.current) {\n      updateMarkers();\n\n      // Добавляем обработчик события закрытия попапа\n      const popupCloseHandler = () => {\n        // Обрабатываем только если закрытие не программное\n        if (!isProgrammaticClose.current) {\n          if (activeMarkerRef.current) {\n            // Только если закрытие инициировано пользователем\n            activeMarkerRef.current.setIcon(defaultIcon);\n            activeMarkerRef.current = null;\n\n            // Сообщаем, что попап закрыт пользователем\n            if (onPopupClose) {\n              onPopupClose();\n            }\n          }\n        }\n        // Сбрасываем флаг после использования\n        isProgrammaticClose.current = false;\n      };\n\n      // Удаляем старый обработчик, если он есть, и добавляем новый\n      mapRef.current.off('popupclose');\n      mapRef.current.on('popupclose', popupCloseHandler);\n      return () => {\n        if (mapRef.current) {\n          mapRef.current.off('popupclose', popupCloseHandler);\n        }\n      };\n    }\n  }, [updateMarkers, defaultIcon, onPopupClose, mapRef]);\n\n  // Обрабатываем изменение selectedPlace\n  useEffect(() => {\n    var _markersRef$current3;\n    if (!mapRef.current || !selectedPlace) return;\n\n    // Пытаемся найти маркер для выбранного места\n    const allLayers = ((_markersRef$current3 = markersRef.current) === null || _markersRef$current3 === void 0 ? void 0 : _markersRef$current3.getLayers()) || [];\n    const allMarkers = allLayers;\n\n    // Маркер не найден, обновляем все маркеры\n    if (allMarkers.length === 0) {\n      updateMarkers();\n      return;\n    }\n\n    // Центрируем карту на выбранном месте если selectedPlace изменился\n    const currentZoom = mapRef.current.getZoom();\n    const targetZoom = currentZoom >= 16 ? currentZoom : 16;\n    mapRef.current.setView([selectedPlace.lat, selectedPlace.lng], targetZoom, {\n      animate: true,\n      duration: 0.5\n    });\n  }, [selectedPlace, updateMarkers, mapRef]);\n\n  // Отслеживаем изменения границ карты с дебаунсингом\n  useEffect(() => {\n    if (!mapRef.current) return;\n    const handleMove = () => {\n      if (boundsTimeoutRef.current) {\n        window.clearTimeout(boundsTimeoutRef.current);\n      }\n      boundsTimeoutRef.current = window.setTimeout(() => {\n        if (!mapRef.current) return;\n        const bounds = mapRef.current.getBounds();\n        if (bounds && onBoundsChangeRef.current) {\n          onBoundsChangeRef.current(bounds);\n        }\n      }, 250); // Увеличиваем задержку для лучшего дебаунсинга\n    };\n    mapRef.current.on('moveend', handleMove);\n    mapRef.current.on('zoomend', handleMove);\n\n    // Вызываем handleMove только при первом рендере\n    if (!isInitialBoundsSet.current) {\n      window.setTimeout(() => {\n        if (mapRef.current) {\n          isInitialBoundsSet.current = true; // Устанавливаем флаг до вызова handleMove\n          handleMove();\n        }\n      }, 200);\n    }\n    return () => {\n      if (mapRef.current) {\n        mapRef.current.off('moveend', handleMove);\n        mapRef.current.off('zoomend', handleMove);\n      }\n      if (boundsTimeoutRef.current) {\n        window.clearTimeout(boundsTimeoutRef.current);\n      }\n    };\n  }, [mapRef]);\n  return /*#__PURE__*/_jsxDEV(MapContainer, {\n    ref: containerRef,\n    className: \"map-wrapper\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 663,\n    columnNumber: 5\n  }, this);\n};\n_s(Map, \"gIqFMyXYTRfZ3i3IT9jXWuKMmHI=\");\n_c2 = Map;\nexport default Map;\nvar _c, _c2;\n$RefreshReg$(_c, \"MapContainer\");\n$RefreshReg$(_c2, \"Map\");","map":{"version":3,"names":["React","useEffect","useRef","useCallback","useMemo","L","styled","jsxDEV","_jsxDEV","Icon","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","require","iconUrl","shadowUrl","MapContainer","div","_c","createPopupContent","place","image","name","description","instagram","maps_url","Map","places","config","onMarkerClick","selectedPlace","mapRef","onPopupClose","onBoundsChange","_s","markersRef","activeMarkerRef","containerRef","mobilePopupRef","isProgrammaticClose","isInitialBoundsSet","onBoundsChangeRef","updateTimeoutRef","boundsTimeoutRef","markersArrayRef","lastVisibilityStateRef","updateCountRef","current","defaultIcon","divIcon","className","iconSize","iconAnchor","html","customIcon","popupAnchor","popupDiv","document","createElement","body","appendChild","removeChild","showMobilePopup","popupContent","innerHTML","classList","add","closeBtn","querySelector","addEventListener","remove","setIcon","createMarkerClusterGroup","markerClusterGroup","iconCreateFunction","cluster","count","getChildCount","point","disableClusteringAtZoom","mapSettings","clusterSettings","spiderfyOnMaxZoom","maxClusterRadius","zoomToBoundsOnClick","showCoverageOnHover","animate","animateAddingMarkers","shouldShowLabel","marker","visibleMarkers","length","markerPoint","latLngToContainerPoint","getLatLng","minDistance","otherMarker","otherPoint","distance","distanceTo","center","getCenter","centerPoint","distToCenter","otherDistToCenter","updateLabelsVisibility","window","clearTimeout","currentCount","setTimeout","markers","zoom","getZoom","hasVisibleMarkers","Object","values","some","state","forEach","tooltip","getTooltip","setOpacity","_markersRef$current","parent","getVisibleParent","push","tooltipVisibility","markerId","_leaflet_id","hasChanges","_tooltip$getElement","shouldBeVisible","includes","isVisible","getElement","style","opacity","updateMarkers","clearLayers","_markersRef$current2","lat","lng","icon","riseOnHover","riseOffset","innerWidth","popup","maxWidth","closeButton","closeOnClick","autoPan","autoPanPadding","setContent","bindPopup","bindTooltip","permanent","direction","offset","on","_mapRef$current","_mapRef$current2","closePopup","currentZoom","targetZoom","setView","duration","openPopup","addLayer","e","layer","childMarkers","getAllChildMarkers","fire","_mapRef$current3","handleMapChange","off","map","initialZoom","scrollWheelZoom","closePopupOnClick","tap","attributionControl","zoomControl","maxZoom","minZoom","bounceAtZoomLimits","inertia","tileLayer","url","attribution","subdomains","preferCanvas","addTo","control","position","prefix","preventDefaultTouchMoveOnMap","target","closest","preventDefault","passive","resizeTimeout","handleResize","invalidateSize","pan","removeEventListener","popupCloseHandler","_markersRef$current3","allLayers","getLayers","allMarkers","handleMove","bounds","getBounds","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["/Users/borvel/Documents/GitHub/places-app/src/components/Map/Map.tsx"],"sourcesContent":["import React, { useEffect, useRef, useCallback, useMemo } from 'react';\nimport L from 'leaflet';\nimport 'leaflet/dist/leaflet.css';\nimport 'leaflet.markercluster';\nimport 'leaflet.markercluster/dist/MarkerCluster.css';\nimport 'leaflet.markercluster/dist/MarkerCluster.Default.css';\nimport { Place, AppConfig } from '../../types/places';\nimport { styled } from 'styled-components';\n\n// Fix for default icon\ndelete (L.Icon.Default.prototype as any)._getIconUrl;\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\n  iconUrl: require('leaflet/dist/images/marker-icon.png'),\n  shadowUrl: require('leaflet/dist/images/marker-shadow.png'),\n});\n\ninterface MapProps {\n  places: Place[];\n  config: AppConfig;\n  onMarkerClick: (place: Place) => void;\n  selectedPlace?: Place | null;\n  mapRef: React.MutableRefObject<L.Map | null>;\n  onPopupClose?: () => void;\n  onBoundsChange?: (bounds: L.LatLngBounds) => void;\n}\n\nconst MapContainer = styled.div`\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 1;\n  will-change: transform;\n  transform: translateZ(0);\n  backface-visibility: hidden;\n  perspective: 1000px;\n`;\n\n// Расширяем интерфейс MapOptions для поддержки дополнительных свойств\ndeclare module 'leaflet' {\n  interface MapOptions {\n    tap?: boolean;\n  }\n\n  interface TileLayerOptions {\n    preferCanvas?: boolean;\n  }\n}\n\nconst createPopupContent = (place: Place) => `\n  <div class=\"place-card\">\n    <img src=\"${place.image}\" alt=\"${place.name}\" class=\"place-image\" style=\"width: 100%; height: 200px; object-fit: cover;\" />\n    <div class=\"place-content\" style=\"padding: 15px;\">\n      <h3 style=\"margin: 0; font-size: 18px;\">${place.name}</h3>\n      <p style=\"margin: 10px 0; font-size: 14px;\">${place.description}</p>\n      <div class=\"place-links-social\" style=\"margin-top: 10px;\">\n        ${place.instagram ? `<a href=\"${place.instagram}\" target=\"_blank\"><img src=\"/data/images/instagram.svg\" alt=\"Instagram\" style=\"width: 27px; height: 27px;\" /></a>` : ''}\n        ${place.maps_url ? `<a href=\"${place.maps_url}\" target=\"_blank\"><img src=\"/data/images/google.svg\" alt=\"Google Maps\" style=\"width: 27px; height: 27px;\" /></a>` : ''}\n      </div>\n    </div>\n  </div>\n`;\n\nexport const Map: React.FC<MapProps> = ({ places, config, onMarkerClick, selectedPlace, mapRef, onPopupClose, onBoundsChange }) => {\n  const markersRef = useRef<L.MarkerClusterGroup | null>(null);\n  const activeMarkerRef = useRef<L.Marker | null>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const mobilePopupRef = useRef<HTMLDivElement | null>(null);\n  // Флаг для отслеживания программного закрытия попапа\n  const isProgrammaticClose = useRef(false);\n  // Флаг для отслеживания первой установки границ\n  const isInitialBoundsSet = useRef(false);\n  // Храним ссылку на функцию обратного вызова на верхнем уровне\n  const onBoundsChangeRef = useRef(onBoundsChange);\n  // Ссылка для хранения таймаута updateLabelsVisibility\n  const updateTimeoutRef = useRef<number | null>(null);\n  // Ссылка для хранения таймаута обновления границ\n  const boundsTimeoutRef = useRef<number | null>(null);\n  // Храним ссылку на массив маркеров для оптимизации\n  const markersArrayRef = useRef<L.Marker[]>([]);\n  // Храним результаты предыдущего расчёта видимости для предотвращения ненужных обновлений\n  const lastVisibilityStateRef = useRef<Record<string, boolean>>({});\n  // Счётчик обновлений для оптимизации\n  const updateCountRef = useRef(0);\n\n  // Обновляем ссылку при изменении функции\n  useEffect(() => {\n    onBoundsChangeRef.current = onBoundsChange;\n  }, [onBoundsChange]);\n\n  // Мемоизируем создание иконок для предотвращения повторных созданий\n  const defaultIcon = useMemo(() => {\n    return L.divIcon({\n      className: 'marker-default',\n      iconSize: [30, 30],\n      iconAnchor: [15, 15],\n      html: '<div></div>'\n    });\n  }, []);\n\n  const customIcon = useMemo(() => {\n    return L.divIcon({\n      className: 'marker-active',\n      iconSize: [30, 40],\n      iconAnchor: [15, 40],\n      popupAnchor: [0, -40],\n      html: '<div></div>'\n    });\n  }, []);\n\n  // Создаем мобильный попап\n  useEffect(() => {\n    if (!mobilePopupRef.current) {\n      const popupDiv = document.createElement('div');\n      popupDiv.className = 'map-popup-mobile';\n      document.body.appendChild(popupDiv);\n      mobilePopupRef.current = popupDiv;\n\n      return () => {\n        document.body.removeChild(popupDiv);\n        mobilePopupRef.current = null;\n      };\n    }\n  }, []);\n\n  const showMobilePopup = useCallback((place: Place) => {\n    if (!mobilePopupRef.current) return;\n\n    const popupContent = `\n      <div class=\"place-card\">\n        <img src=\"${place.image}\" alt=\"${place.name}\" class=\"place-image\" />\n        <div class=\"place-content\">\n          <h3>${place.name}</h3>\n          <p>${place.description}</p>\n          <div class=\"place-links-social\">\n            ${place.instagram ? `<a href=\"${place.instagram}\" target=\"_blank\"><img src=\"/data/images/instagram.svg\" alt=\"Instagram\" /></a>` : ''}\n            ${place.maps_url ? `<a href=\"${place.maps_url}\" target=\"_blank\"><img src=\"/data/images/google.svg\" alt=\"Google Maps\" /></a>` : ''}\n          </div>\n        </div>\n        <button class=\"close-btn-mobile\">×</button>\n      </div>\n    `;\n\n    mobilePopupRef.current.innerHTML = popupContent;\n    mobilePopupRef.current.classList.add('active');\n\n    const closeBtn = mobilePopupRef.current.querySelector('.close-btn-mobile');\n    if (closeBtn) {\n      closeBtn.addEventListener('click', () => {\n        if (mobilePopupRef.current) {\n          mobilePopupRef.current.classList.remove('active');\n          if (activeMarkerRef.current) {\n            activeMarkerRef.current.setIcon(defaultIcon);\n            activeMarkerRef.current = null;\n          }\n\n          // Сообщаем, что попап закрыт, чтобы сбросить selectedPlace\n          if (onPopupClose) {\n            onPopupClose();\n          }\n        }\n      });\n    }\n  }, [onPopupClose, defaultIcon]);\n\n  const createMarkerClusterGroup = useCallback(() => {\n    return L.markerClusterGroup({\n      iconCreateFunction: (cluster: L.MarkerCluster) => {\n        const count = cluster.getChildCount();\n        return L.divIcon({\n          html: `<div class=\"cluster-icon\">${count}</div>`,\n          className: 'marker-cluster',\n          iconSize: L.point(40, 40)\n        });\n      },\n      disableClusteringAtZoom: config.mapSettings.clusterSettings.disableClusteringAtZoom,\n      spiderfyOnMaxZoom: false,\n      maxClusterRadius: config.mapSettings.clusterSettings.maxClusterRadius,\n      zoomToBoundsOnClick: false,\n      showCoverageOnHover: false,\n      animate: true,\n      animateAddingMarkers: false\n    });\n  }, [config.mapSettings.clusterSettings]);\n\n  // Функция для проверки наложения меток\n  const shouldShowLabel = useCallback((marker: L.Marker, visibleMarkers: L.Marker[]): boolean => {\n    if (!mapRef.current) return false;\n    \n    // Одиночные метки всегда показываем\n    if (visibleMarkers.length <= 1) return true;\n\n    const markerPoint = mapRef.current.latLngToContainerPoint(marker.getLatLng());\n    if (!markerPoint) return false;\n\n    // Минимальное расстояние между метками в пикселях\n    const minDistance = 100;\n\n    // Проверяем расстояние до других видимых меток\n    for (const otherMarker of visibleMarkers) {\n      if (marker === otherMarker) continue;\n\n      const otherPoint = mapRef.current.latLngToContainerPoint(otherMarker.getLatLng());\n      if (!otherPoint) continue;\n\n      const distance = markerPoint.distanceTo(otherPoint);\n      if (distance < minDistance) {\n        // Если метки слишком близко, показываем только ту, что ближе к центру экрана\n        const center = mapRef.current.getCenter();\n        if (!center) continue;\n\n        const centerPoint = mapRef.current.latLngToContainerPoint(center);\n        if (!centerPoint) continue;\n\n        const distToCenter = markerPoint.distanceTo(centerPoint);\n        const otherDistToCenter = otherPoint.distanceTo(centerPoint);\n\n        // Если эта метка дальше от центра, скрываем её\n        if (distToCenter > otherDistToCenter) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }, [mapRef]);\n\n  // Создаем дебаунсированную функцию обновления видимости меток\n  const updateLabelsVisibility = useCallback(() => {\n    // Отменяем предыдущий таймаут, если он есть\n    if (updateTimeoutRef.current) {\n      window.clearTimeout(updateTimeoutRef.current);\n    }\n    \n    // Счетчик обновлений (избегаем слишком частых обновлений)\n    updateCountRef.current++;\n    const currentCount = updateCountRef.current;\n    \n    // Устанавливаем новый таймаут с увеличенной задержкой\n    updateTimeoutRef.current = window.setTimeout(() => {\n      // Пропускаем, если выполняется более новое обновление\n      if (currentCount !== updateCountRef.current) return;\n      \n      if (!mapRef.current || !markersRef.current) return;\n      const markers = markersArrayRef.current;\n      if (markers.length === 0) return;\n\n      const zoom = mapRef.current.getZoom();\n\n      // Для небольшого зума скрываем все названия\n      if (zoom < 14) {\n        // Скрываем только если они были видимы\n        const hasVisibleMarkers = Object.values(lastVisibilityStateRef.current).some(state => state);\n        if (hasVisibleMarkers) {\n          markers.forEach(marker => {\n            const tooltip = marker.getTooltip();\n            if (tooltip) tooltip.setOpacity(0);\n          });\n          \n          // Обновляем состояние видимости\n          lastVisibilityStateRef.current = {};\n        }\n        return;\n      }\n\n      // Кэшируем видимые маркеры для уменьшения вычислений\n      const visibleMarkers: L.Marker[] = [];\n      markers.forEach(marker => {\n        // Проверяем, является ли родитель маркера кластером\n        const parent = markersRef.current?.getVisibleParent(marker);\n        if (parent === marker) {\n          visibleMarkers.push(marker);\n        }\n      });\n\n      // Если нет видимых маркеров, пропускаем\n      if (visibleMarkers.length === 0) return;\n\n      // Используем обычный объект для отслеживания изменений видимости\n      const tooltipVisibility: Record<string, boolean> = {};\n      \n      // Определяем, какие маркеры должны быть видимыми\n      visibleMarkers.forEach(marker => {\n        const markerId = (marker as any)._leaflet_id;\n        tooltipVisibility[markerId] = shouldShowLabel(marker, visibleMarkers);\n      });\n      \n      // Проверяем, изменилось ли что-то в состоянии видимости\n      let hasChanges = false;\n      for (const markerId in tooltipVisibility) {\n        if (tooltipVisibility[markerId] !== lastVisibilityStateRef.current[markerId]) {\n          hasChanges = true;\n          break;\n        }\n      }\n      \n      // Если состояние не изменилось, пропускаем обновления\n      if (!hasChanges) return;\n      \n      // Обновляем только маркеры, состояние которых изменилось\n      markers.forEach(marker => {\n        const tooltip = marker.getTooltip();\n        if (!tooltip) return;\n        \n        // Проверяем, должна ли метка быть видимой\n        const markerId = (marker as any)._leaflet_id;\n        const shouldBeVisible = tooltipVisibility[markerId] && visibleMarkers.includes(marker);\n        const isVisible = tooltip.getElement()?.style.opacity !== '0';\n        \n        // Обновляем только если состояние изменилось\n        if (shouldBeVisible !== isVisible) {\n          tooltip.setOpacity(shouldBeVisible ? 1 : 0);\n        }\n      });\n      \n      // Сохраняем текущее состояние для следующего сравнения\n      lastVisibilityStateRef.current = { ...tooltipVisibility };\n    }, 200); // Увеличиваем задержку для лучшего дебаунсинга\n  }, [shouldShowLabel, mapRef]);\n\n  const updateMarkers = useCallback(() => {\n    if (!mapRef.current || !markersRef.current) return;\n\n    // Очищаем все слои, включая предыдущие маркеры\n    markersRef.current.clearLayers();\n\n    // Сбрасываем активный маркер и массив маркеров\n    activeMarkerRef.current = null;\n    markersArrayRef.current = [];\n\n    // Создаем маркеры с tooltips\n    const markers: L.Marker[] = [];\n    places.forEach(place => {\n      const marker = L.marker([place.lat, place.lng], {\n        icon: defaultIcon,\n        riseOnHover: true,\n        riseOffset: 250\n      });\n\n      if (window.innerWidth > 768) {\n        const popup = L.popup({\n          maxWidth: 500,\n          className: 'place-popup',\n          closeButton: true,\n          closeOnClick: false,\n          autoPan: true,\n          autoPanPadding: [50, 50]\n        }).setContent(createPopupContent(place));\n\n        marker.bindPopup(popup);\n      }\n\n      // Создаем tooltip и делаем его невидимым по умолчанию\n      marker.bindTooltip(place.name, {\n        permanent: true,\n        direction: 'bottom',\n        offset: [0, 5],\n        className: 'place-label',\n        opacity: 0\n      });\n\n      // Добавляем место в данные маркера для доступа в дальнейшем\n      (marker as any).place = place;\n\n      marker.on('click', () => {\n        // При клике на тот же маркер, отменяем выбор\n        if (activeMarkerRef.current === marker) {\n          marker.setIcon(defaultIcon);\n          if (window.innerWidth > 768) {\n            isProgrammaticClose.current = true;\n            marker.closePopup();\n          }\n          activeMarkerRef.current = null;\n          onMarkerClick(place); // Передаем повторный клик для отмены выбора\n          return;\n        }\n\n        // При клике на другой маркер\n        if (activeMarkerRef.current && activeMarkerRef.current !== marker) {\n          activeMarkerRef.current.setIcon(defaultIcon);\n          if (window.innerWidth > 768) {\n            isProgrammaticClose.current = true;\n            activeMarkerRef.current.closePopup();\n          }\n        }\n\n        marker.setIcon(customIcon);\n        activeMarkerRef.current = marker;\n\n        // Центрируем карту с проверкой зума\n        const currentZoom = mapRef.current?.getZoom() || 0;\n        const targetZoom = currentZoom >= 16 ? currentZoom : 16;\n\n        mapRef.current?.setView(marker.getLatLng(), targetZoom, {\n          animate: true,\n          duration: 0.5\n        });\n\n        if (window.innerWidth > 768) {\n          marker.openPopup();\n        } else {\n          showMobilePopup(place);\n        }\n\n        onMarkerClick(place);\n      });\n\n      markers.push(marker);\n      markersRef.current?.addLayer(marker);\n\n      // Устанавливаем активный маркер для выбранного места\n      if (selectedPlace && selectedPlace.name === place.name) {\n        marker.setIcon(customIcon);\n        activeMarkerRef.current = marker;\n\n        if (window.innerWidth > 768) {\n          marker.openPopup();\n        } else {\n          showMobilePopup(place);\n        }\n      }\n    });\n\n    // Сохраняем ссылку на массив маркеров\n    markersArrayRef.current = markers;\n\n    // Добавляем обработчик клика на кластер\n    markersRef.current.on('clusterclick', (e: L.LeafletEvent) => {\n      const cluster = e.layer as L.MarkerCluster;\n      const childMarkers = cluster.getAllChildMarkers();\n\n      if (childMarkers.length === 1) {\n        childMarkers[0].fire('click');\n      } else {\n        mapRef.current?.setView(cluster.getLatLng(), 16, { animate: true });\n      }\n\n      // Обновляем видимость названий после раскрытия кластера с большей задержкой\n      setTimeout(updateLabelsVisibility, 300);\n    });\n\n    // Используем единый обработчик для событий с дебаунсингом\n    const handleMapChange = () => updateLabelsVisibility();\n\n    // События, при которых нужно обновлять видимость названий\n    mapRef.current.on('zoomend', handleMapChange);\n    mapRef.current.on('moveend', handleMapChange);\n    markersRef.current.on('animationend', handleMapChange);\n\n    // Обновляем сразу после создания маркеров\n    setTimeout(updateLabelsVisibility, 100);\n    \n    // Очистка обработчиков и таймаутов при размонтировании\n    return () => {\n      if (updateTimeoutRef.current) {\n        window.clearTimeout(updateTimeoutRef.current);\n      }\n      \n      if (mapRef.current) {\n        mapRef.current.off('zoomend', handleMapChange);\n        mapRef.current.off('moveend', handleMapChange);\n      }\n      \n      if (markersRef.current) {\n        markersRef.current.off('animationend', handleMapChange);\n      }\n    };\n  }, [places, selectedPlace, defaultIcon, customIcon, mapRef, onMarkerClick, showMobilePopup, updateLabelsVisibility]);\n\n  useEffect(() => {\n    if (!containerRef.current || mapRef.current) return;\n\n    const map = L.map(containerRef.current, {\n      center: config.mapSettings.center,\n      zoom: config.mapSettings.initialZoom,\n      scrollWheelZoom: true,\n      closePopupOnClick: true,\n      tap: false,\n      attributionControl: false,\n      zoomControl: false,\n      maxZoom: config.mapSettings.maxZoom,\n      minZoom: config.mapSettings.initialZoom - 2,\n      bounceAtZoomLimits: false,\n      inertia: false\n    });\n\n    L.tileLayer(config.mapSettings.tileLayer.url, {\n      attribution: config.mapSettings.tileLayer.attribution,\n      subdomains: config.mapSettings.tileLayer.subdomains,\n      maxZoom: config.mapSettings.maxZoom,\n      minZoom: config.mapSettings.initialZoom - 2,\n      preferCanvas: true\n    }).addTo(map);\n\n    L.control.attribution({\n      position: 'bottomright',\n      prefix: false\n    }).addTo(map);\n\n    L.control.zoom({\n      position: 'topright'\n    }).addTo(map);\n\n    mapRef.current = map;\n    markersRef.current = createMarkerClusterGroup();\n    map.addLayer(markersRef.current);\n\n    // Добавляем глобальный обработчик touchmove для предотвращения скроллинга страницы\n    // при взаимодействии с картой\n    const preventDefaultTouchMoveOnMap = (e: TouchEvent) => {\n      if (e.target && \n         (e.target as HTMLElement).closest('.leaflet-container')) {\n        e.preventDefault();\n      }\n    };\n\n    // Добавляем обработчик на уровне документа с passive: false,\n    // чтобы иметь возможность вызывать preventDefault()\n    document.addEventListener('touchmove', preventDefaultTouchMoveOnMap, { passive: false });\n\n    // Используем throttling для обработчика изменения размера\n    let resizeTimeout: number | null = null;\n    const handleResize = () => {\n      if (resizeTimeout) return;\n      \n      resizeTimeout = window.setTimeout(() => {\n        map.invalidateSize({ animate: false, pan: false });\n        resizeTimeout = null;\n      }, 100);\n    };\n\n    window.addEventListener('resize', handleResize);\n    window.addEventListener('orientationchange', handleResize);\n\n    // Используем явный window.setTimeout для избежания проблем с асинхронностью\n    window.setTimeout(handleResize, 100);\n\n    return () => {\n      document.removeEventListener('touchmove', preventDefaultTouchMoveOnMap);\n      window.removeEventListener('resize', handleResize);\n      window.removeEventListener('orientationchange', handleResize);\n      \n      // Очищаем таймауты\n      if (updateTimeoutRef.current) {\n        window.clearTimeout(updateTimeoutRef.current);\n      }\n      \n      if (resizeTimeout) {\n        window.clearTimeout(resizeTimeout);\n      }\n      \n      map.remove();\n      mapRef.current = null;\n      markersRef.current = null;\n    };\n  }, [config, createMarkerClusterGroup, mapRef]);\n\n  useEffect(() => {\n    if (mapRef.current && markersRef.current) {\n      updateMarkers();\n\n      // Добавляем обработчик события закрытия попапа\n      const popupCloseHandler = () => {\n        // Обрабатываем только если закрытие не программное\n        if (!isProgrammaticClose.current) {\n          if (activeMarkerRef.current) {\n            // Только если закрытие инициировано пользователем\n            activeMarkerRef.current.setIcon(defaultIcon);\n            activeMarkerRef.current = null;\n\n            // Сообщаем, что попап закрыт пользователем\n            if (onPopupClose) {\n              onPopupClose();\n            }\n          }\n        }\n        // Сбрасываем флаг после использования\n        isProgrammaticClose.current = false;\n      };\n\n      // Удаляем старый обработчик, если он есть, и добавляем новый\n      mapRef.current.off('popupclose');\n      mapRef.current.on('popupclose', popupCloseHandler);\n\n      return () => {\n        if (mapRef.current) {\n          mapRef.current.off('popupclose', popupCloseHandler);\n        }\n      };\n    }\n  }, [updateMarkers, defaultIcon, onPopupClose, mapRef]);\n\n  // Обрабатываем изменение selectedPlace\n  useEffect(() => {\n    if (!mapRef.current || !selectedPlace) return;\n\n    // Пытаемся найти маркер для выбранного места\n    const allLayers = markersRef.current?.getLayers() || [];\n    const allMarkers = allLayers as L.Marker[];\n\n    // Маркер не найден, обновляем все маркеры\n    if (allMarkers.length === 0) {\n      updateMarkers();\n      return;\n    }\n\n    // Центрируем карту на выбранном месте если selectedPlace изменился\n    const currentZoom = mapRef.current.getZoom();\n    const targetZoom = currentZoom >= 16 ? currentZoom : 16;\n\n    mapRef.current.setView([selectedPlace.lat, selectedPlace.lng], targetZoom, {\n      animate: true,\n      duration: 0.5\n    });\n  }, [selectedPlace, updateMarkers, mapRef]);\n\n  // Отслеживаем изменения границ карты с дебаунсингом\n  useEffect(() => {\n    if (!mapRef.current) return;\n    \n    const handleMove = () => {\n      if (boundsTimeoutRef.current) {\n        window.clearTimeout(boundsTimeoutRef.current);\n      }\n      \n      boundsTimeoutRef.current = window.setTimeout(() => {\n        if (!mapRef.current) return;\n        const bounds = mapRef.current.getBounds();\n        if (bounds && onBoundsChangeRef.current) {\n          onBoundsChangeRef.current(bounds);\n        }\n      }, 250); // Увеличиваем задержку для лучшего дебаунсинга\n    };\n\n    mapRef.current.on('moveend', handleMove);\n    mapRef.current.on('zoomend', handleMove);\n\n    // Вызываем handleMove только при первом рендере\n    if (!isInitialBoundsSet.current) {\n      window.setTimeout(() => {\n        if (mapRef.current) {\n          isInitialBoundsSet.current = true; // Устанавливаем флаг до вызова handleMove\n          handleMove();\n        }\n      }, 200);\n    }\n\n    return () => {\n      if (mapRef.current) {\n        mapRef.current.off('moveend', handleMove);\n        mapRef.current.off('zoomend', handleMove);\n      }\n      \n      if (boundsTimeoutRef.current) {\n        window.clearTimeout(boundsTimeoutRef.current);\n      }\n    };\n  }, [mapRef]); \n\n  return (\n    <MapContainer \n      ref={containerRef} \n      className=\"map-wrapper\"\n    />\n  );\n};\n\nexport default Map;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}