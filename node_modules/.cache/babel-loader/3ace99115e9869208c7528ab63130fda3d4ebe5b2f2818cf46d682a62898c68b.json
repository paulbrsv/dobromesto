{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useCallback } from 'react';\nimport { useSearchParams } from 'react-router-dom';\n// Глобальная Map для хранения состояния фильтров в UI\nif (!window.filterStates) {\n  window.filterStates = new Map();\n}\n\n// Глобальный Set для хранения фильтров, которые были явно удалены\nif (!window.removedFilters) {\n  window.removedFilters = new Set();\n}\n\n// Глобальный Set для хранения фильтров, которые были удалены из URL\nif (!window.urlRemovedFilters) {\n  window.urlRemovedFilters = new Set();\n}\nexport const useUrlFilters = (activeFilters, onFilterChange, filterCounts) => {\n  _s();\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  // Функция для проверки валидности фильтров\n  const getValidFilters = useCallback(currentFilters => {\n    var _window$places;\n    if (!((_window$places = window.places) !== null && _window$places !== void 0 && _window$places.length)) return [];\n\n    // Если нет фильтров, то возвращаем пустой массив\n    if (!currentFilters.length) return [];\n\n    // Создаем результирующий массив валидных фильтров\n    const validFilters = [];\n\n    // Постепенно фильтруем места, применяя каждый фильтр последовательно\n    let filteredPlaces = [...window.places];\n\n    // Проверяем каждый фильтр последовательно\n    for (const filter of currentFilters) {\n      // Получаем места, соответствующие текущему фильтру из уже отфильтрованных\n      const placesWithFilter = filteredPlaces.filter(place => place.attributes.includes(filter));\n\n      // Если есть хотя бы одно место с этим фильтром, считаем его валидным\n      if (placesWithFilter.length > 0) {\n        validFilters.push(filter);\n        filteredPlaces = placesWithFilter; // Обновляем список мест для следующего фильтра\n      }\n    }\n    return validFilters;\n  }, []);\n\n  // Функция для прямого установления URL с некодированными запятыми\n  const setFiltersInUrl = useCallback(filters => {\n    if (!filters || filters.length === 0) {\n      // Удаляем параметр filter из URL\n      const path = window.location.pathname;\n      window.history.pushState({}, '', path);\n\n      // Принудительно обновляем React Router\n      window.dispatchEvent(new Event('popstate'));\n      return;\n    }\n\n    // Используем history API для прямого изменения URL без кодирования запятых\n    const path = window.location.pathname;\n    const newUrl = `${path}?filter=${filters.join(',')}`;\n    window.history.pushState({}, '', newUrl);\n\n    // Принудительно обновляем React Router\n    window.dispatchEvent(new Event('popstate'));\n  }, []);\n\n  // Обработка изменений URL\n  useEffect(() => {\n    var _window$places2;\n    if (!((_window$places2 = window.places) !== null && _window$places2 !== void 0 && _window$places2.length)) return;\n\n    // Получаем фильтры из URL\n    const filtersFromUrl = searchParams.get('filter');\n\n    // Если URL пустой, сбрасываем все фильтры\n    if (!filtersFromUrl) {\n      window.filterStates.clear();\n      onFilterChange([]);\n      return;\n    }\n\n    // Получаем список фильтров из URL\n    const requestedFilters = filtersFromUrl.split(',').filter(Boolean);\n\n    // Проверяем, все ли фильтры валидны\n    const validFilters = getValidFilters(requestedFilters);\n\n    // Если есть невалидные фильтры, обновляем URL\n    if (validFilters.join(',') !== requestedFilters.join(',')) {\n      if (validFilters.length > 0) {\n        setFiltersInUrl(validFilters);\n      } else {\n        setFiltersInUrl(null);\n      }\n\n      // Останавливаем выполнение, т.к. изменение URL вызовет повторный запуск useEffect\n      return;\n    }\n\n    // Обновляем UI-состояние\n    window.filterStates.clear();\n    validFilters.forEach(filter => {\n      window.filterStates.set(filter, true);\n    });\n\n    // Вызываем коллбэк для обновления состояния в родительском компоненте\n    onFilterChange(validFilters);\n  }, [searchParams, onFilterChange, getValidFilters, setFiltersInUrl]);\n\n  // Обработка клика по фильтру\n  const toggleFilter = useCallback(filter => {\n    var _window$places3;\n    if (!((_window$places3 = window.places) !== null && _window$places3 !== void 0 && _window$places3.length)) return;\n\n    // Получаем текущие фильтры из URL\n    const urlFilter = searchParams.get('filter') || '';\n    const currentFilters = urlFilter ? urlFilter.split(',').filter(Boolean) : [];\n    const isActive = currentFilters.includes(filter);\n    if (isActive) {\n      // Удаляем фильтр из списка\n      const newFilters = currentFilters.filter(f => f !== filter);\n\n      // Обновляем UI-состояние\n      window.filterStates.delete(filter);\n\n      // Обновляем URL\n      if (newFilters.length > 0) {\n        setFiltersInUrl(newFilters);\n      } else {\n        setFiltersInUrl(null);\n      }\n    } else {\n      // Добавляем фильтр, только если у него есть места (счетчик > 0)\n      if (filterCounts[filter] && filterCounts[filter] > 0) {\n        // Проверяем, будет ли фильтр валидным при добавлении\n        const newFilters = [...currentFilters, filter];\n        const validFilters = getValidFilters(newFilters);\n\n        // Добавляем фильтр только если он валиден в контексте текущих фильтров\n        if (validFilters.includes(filter)) {\n          // Обновляем UI-состояние\n          window.filterStates.set(filter, true);\n\n          // Обновляем URL\n          setFiltersInUrl(validFilters);\n        }\n      }\n    }\n  }, [searchParams, filterCounts, getValidFilters, setFiltersInUrl]);\n\n  // Функция для полного сброса фильтров\n  const resetFilters = useCallback(() => {\n    // Полностью очищаем состояние\n    window.filterStates.clear();\n\n    // Очищаем URL\n    setFiltersInUrl(null);\n  }, [setFiltersInUrl]);\n  return {\n    toggleFilter,\n    isFilterAvailable: useCallback(filter => {\n      // Если фильтр уже активен, он доступен\n      if (activeFilters.includes(filter)) {\n        return true;\n      }\n\n      // Иначе проверяем, есть ли для него места\n      return (filterCounts[filter] || 0) > 0;\n    }, [activeFilters]),\n    resetFilters\n  };\n};\n\n// Добавляем типы для window\n_s(useUrlFilters, \"4tAkMnKPyF2cp2q+myn3VbnRdLI=\", false, function () {\n  return [useSearchParams];\n});\nexport default useUrlFilters;","map":{"version":3,"names":["useEffect","useCallback","useSearchParams","window","filterStates","Map","removedFilters","Set","urlRemovedFilters","useUrlFilters","activeFilters","onFilterChange","filterCounts","_s","searchParams","setSearchParams","getValidFilters","currentFilters","_window$places","places","length","validFilters","filteredPlaces","filter","placesWithFilter","place","attributes","includes","push","setFiltersInUrl","filters","path","location","pathname","history","pushState","dispatchEvent","Event","newUrl","join","_window$places2","filtersFromUrl","get","clear","requestedFilters","split","Boolean","forEach","set","toggleFilter","_window$places3","urlFilter","isActive","newFilters","f","delete","resetFilters","isFilterAvailable"],"sources":["/Users/borvel/Documents/GitHub/places-app/src/hooks/useUrlFilters.ts"],"sourcesContent":["import { useEffect, useCallback } from 'react';\nimport { useSearchParams } from 'react-router-dom';\nimport { Place } from '../types/places';\n\n// Глобальная Map для хранения состояния фильтров в UI\nif (!window.filterStates) {\n  window.filterStates = new Map<string, boolean>();\n}\n\n// Глобальный Set для хранения фильтров, которые были явно удалены\nif (!window.removedFilters) {\n  window.removedFilters = new Set<string>();\n}\n\n// Глобальный Set для хранения фильтров, которые были удалены из URL\nif (!window.urlRemovedFilters) {\n  window.urlRemovedFilters = new Set<string>();\n}\n\nexport const useUrlFilters = (\n  activeFilters: string[],\n  onFilterChange: (filters: string[]) => void,\n  filterCounts: Record<string, number>\n) => {\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  // Функция для проверки валидности фильтров\n  const getValidFilters = useCallback((currentFilters: string[]) => {\n    if (!window.places?.length) return [];\n    \n    // Если нет фильтров, то возвращаем пустой массив\n    if (!currentFilters.length) return [];\n    \n    // Создаем результирующий массив валидных фильтров\n    const validFilters: string[] = [];\n    \n    // Постепенно фильтруем места, применяя каждый фильтр последовательно\n    let filteredPlaces = [...window.places];\n    \n    // Проверяем каждый фильтр последовательно\n    for (const filter of currentFilters) {\n      // Получаем места, соответствующие текущему фильтру из уже отфильтрованных\n      const placesWithFilter = filteredPlaces.filter(place => \n        place.attributes.includes(filter)\n      );\n      \n      // Если есть хотя бы одно место с этим фильтром, считаем его валидным\n      if (placesWithFilter.length > 0) {\n        validFilters.push(filter);\n        filteredPlaces = placesWithFilter; // Обновляем список мест для следующего фильтра\n      }\n    }\n    \n    return validFilters;\n  }, []);\n\n  // Функция для прямого установления URL с некодированными запятыми\n  const setFiltersInUrl = useCallback((filters: string[] | null) => {\n    if (!filters || filters.length === 0) {\n      // Удаляем параметр filter из URL\n      const path = window.location.pathname;\n      window.history.pushState({}, '', path);\n      \n      // Принудительно обновляем React Router\n      window.dispatchEvent(new Event('popstate'));\n      return;\n    }\n\n    // Используем history API для прямого изменения URL без кодирования запятых\n    const path = window.location.pathname;\n    const newUrl = `${path}?filter=${filters.join(',')}`;\n    window.history.pushState({}, '', newUrl);\n    \n    // Принудительно обновляем React Router\n    window.dispatchEvent(new Event('popstate'));\n  }, []);\n\n  // Обработка изменений URL\n  useEffect(() => {\n    if (!window.places?.length) return;\n\n    // Получаем фильтры из URL\n    const filtersFromUrl = searchParams.get('filter');\n    \n    // Если URL пустой, сбрасываем все фильтры\n    if (!filtersFromUrl) {\n      window.filterStates.clear();\n      onFilterChange([]);\n      return;\n    }\n\n    // Получаем список фильтров из URL\n    const requestedFilters = filtersFromUrl.split(',').filter(Boolean);\n    \n    // Проверяем, все ли фильтры валидны\n    const validFilters = getValidFilters(requestedFilters);\n    \n    // Если есть невалидные фильтры, обновляем URL\n    if (validFilters.join(',') !== requestedFilters.join(',')) {\n      if (validFilters.length > 0) {\n        setFiltersInUrl(validFilters);\n      } else {\n        setFiltersInUrl(null);\n      }\n      \n      // Останавливаем выполнение, т.к. изменение URL вызовет повторный запуск useEffect\n      return;\n    }\n\n    // Обновляем UI-состояние\n    window.filterStates.clear();\n    validFilters.forEach(filter => {\n      window.filterStates.set(filter, true);\n    });\n\n    // Вызываем коллбэк для обновления состояния в родительском компоненте\n    onFilterChange(validFilters);\n  }, [searchParams, onFilterChange, getValidFilters, setFiltersInUrl]);\n\n  // Обработка клика по фильтру\n  const toggleFilter = useCallback((filter: string) => {\n    if (!window.places?.length) return;\n    \n    // Получаем текущие фильтры из URL\n    const urlFilter = searchParams.get('filter') || '';\n    const currentFilters = urlFilter ? urlFilter.split(',').filter(Boolean) : [];\n    const isActive = currentFilters.includes(filter);\n    \n    if (isActive) {\n      // Удаляем фильтр из списка\n      const newFilters = currentFilters.filter(f => f !== filter);\n      \n      // Обновляем UI-состояние\n      window.filterStates.delete(filter);\n      \n      // Обновляем URL\n      if (newFilters.length > 0) {\n        setFiltersInUrl(newFilters);\n      } else {\n        setFiltersInUrl(null);\n      }\n    } else {\n      // Добавляем фильтр, только если у него есть места (счетчик > 0)\n      if (filterCounts[filter] && filterCounts[filter] > 0) {\n        // Проверяем, будет ли фильтр валидным при добавлении\n        const newFilters = [...currentFilters, filter];\n        const validFilters = getValidFilters(newFilters);\n        \n        // Добавляем фильтр только если он валиден в контексте текущих фильтров\n        if (validFilters.includes(filter)) {\n          // Обновляем UI-состояние\n          window.filterStates.set(filter, true);\n          \n          // Обновляем URL\n          setFiltersInUrl(validFilters);\n        }\n      }\n    }\n  }, [searchParams, filterCounts, getValidFilters, setFiltersInUrl]);\n\n  // Функция для полного сброса фильтров\n  const resetFilters = useCallback(() => {\n    // Полностью очищаем состояние\n    window.filterStates.clear();\n    \n    // Очищаем URL\n    setFiltersInUrl(null);\n  }, [setFiltersInUrl]);\n\n  return {\n    toggleFilter,\n    isFilterAvailable: useCallback((filter: string) => {\n      // Если фильтр уже активен, он доступен\n      if (activeFilters.includes(filter)) {\n        return true;\n      }\n      \n      // Иначе проверяем, есть ли для него места\n      return (filterCounts[filter] || 0) > 0;\n    }, [activeFilters]),\n    resetFilters\n  };\n};\n\n// Добавляем типы для window\ndeclare global {\n  interface Window {\n    filterStates: Map<string, boolean>;\n    removedFilters: Set<string>;\n    urlRemovedFilters: Set<string>;\n    places: Place[];\n  }\n}\n\nexport default useUrlFilters; "],"mappings":";AAAA,SAASA,SAAS,EAAEC,WAAW,QAAQ,OAAO;AAC9C,SAASC,eAAe,QAAQ,kBAAkB;AAGlD;AACA,IAAI,CAACC,MAAM,CAACC,YAAY,EAAE;EACxBD,MAAM,CAACC,YAAY,GAAG,IAAIC,GAAG,CAAkB,CAAC;AAClD;;AAEA;AACA,IAAI,CAACF,MAAM,CAACG,cAAc,EAAE;EAC1BH,MAAM,CAACG,cAAc,GAAG,IAAIC,GAAG,CAAS,CAAC;AAC3C;;AAEA;AACA,IAAI,CAACJ,MAAM,CAACK,iBAAiB,EAAE;EAC7BL,MAAM,CAACK,iBAAiB,GAAG,IAAID,GAAG,CAAS,CAAC;AAC9C;AAEA,OAAO,MAAME,aAAa,GAAGA,CAC3BC,aAAuB,EACvBC,cAA2C,EAC3CC,YAAoC,KACjC;EAAAC,EAAA;EACH,MAAM,CAACC,YAAY,EAAEC,eAAe,CAAC,GAAGb,eAAe,CAAC,CAAC;;EAEzD;EACA,MAAMc,eAAe,GAAGf,WAAW,CAAEgB,cAAwB,IAAK;IAAA,IAAAC,cAAA;IAChE,IAAI,GAAAA,cAAA,GAACf,MAAM,CAACgB,MAAM,cAAAD,cAAA,eAAbA,cAAA,CAAeE,MAAM,GAAE,OAAO,EAAE;;IAErC;IACA,IAAI,CAACH,cAAc,CAACG,MAAM,EAAE,OAAO,EAAE;;IAErC;IACA,MAAMC,YAAsB,GAAG,EAAE;;IAEjC;IACA,IAAIC,cAAc,GAAG,CAAC,GAAGnB,MAAM,CAACgB,MAAM,CAAC;;IAEvC;IACA,KAAK,MAAMI,MAAM,IAAIN,cAAc,EAAE;MACnC;MACA,MAAMO,gBAAgB,GAAGF,cAAc,CAACC,MAAM,CAACE,KAAK,IAClDA,KAAK,CAACC,UAAU,CAACC,QAAQ,CAACJ,MAAM,CAClC,CAAC;;MAED;MACA,IAAIC,gBAAgB,CAACJ,MAAM,GAAG,CAAC,EAAE;QAC/BC,YAAY,CAACO,IAAI,CAACL,MAAM,CAAC;QACzBD,cAAc,GAAGE,gBAAgB,CAAC,CAAC;MACrC;IACF;IAEA,OAAOH,YAAY;EACrB,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMQ,eAAe,GAAG5B,WAAW,CAAE6B,OAAwB,IAAK;IAChE,IAAI,CAACA,OAAO,IAAIA,OAAO,CAACV,MAAM,KAAK,CAAC,EAAE;MACpC;MACA,MAAMW,IAAI,GAAG5B,MAAM,CAAC6B,QAAQ,CAACC,QAAQ;MACrC9B,MAAM,CAAC+B,OAAO,CAACC,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,EAAEJ,IAAI,CAAC;;MAEtC;MACA5B,MAAM,CAACiC,aAAa,CAAC,IAAIC,KAAK,CAAC,UAAU,CAAC,CAAC;MAC3C;IACF;;IAEA;IACA,MAAMN,IAAI,GAAG5B,MAAM,CAAC6B,QAAQ,CAACC,QAAQ;IACrC,MAAMK,MAAM,GAAG,GAAGP,IAAI,WAAWD,OAAO,CAACS,IAAI,CAAC,GAAG,CAAC,EAAE;IACpDpC,MAAM,CAAC+B,OAAO,CAACC,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,EAAEG,MAAM,CAAC;;IAExC;IACAnC,MAAM,CAACiC,aAAa,CAAC,IAAIC,KAAK,CAAC,UAAU,CAAC,CAAC;EAC7C,CAAC,EAAE,EAAE,CAAC;;EAEN;EACArC,SAAS,CAAC,MAAM;IAAA,IAAAwC,eAAA;IACd,IAAI,GAAAA,eAAA,GAACrC,MAAM,CAACgB,MAAM,cAAAqB,eAAA,eAAbA,eAAA,CAAepB,MAAM,GAAE;;IAE5B;IACA,MAAMqB,cAAc,GAAG3B,YAAY,CAAC4B,GAAG,CAAC,QAAQ,CAAC;;IAEjD;IACA,IAAI,CAACD,cAAc,EAAE;MACnBtC,MAAM,CAACC,YAAY,CAACuC,KAAK,CAAC,CAAC;MAC3BhC,cAAc,CAAC,EAAE,CAAC;MAClB;IACF;;IAEA;IACA,MAAMiC,gBAAgB,GAAGH,cAAc,CAACI,KAAK,CAAC,GAAG,CAAC,CAACtB,MAAM,CAACuB,OAAO,CAAC;;IAElE;IACA,MAAMzB,YAAY,GAAGL,eAAe,CAAC4B,gBAAgB,CAAC;;IAEtD;IACA,IAAIvB,YAAY,CAACkB,IAAI,CAAC,GAAG,CAAC,KAAKK,gBAAgB,CAACL,IAAI,CAAC,GAAG,CAAC,EAAE;MACzD,IAAIlB,YAAY,CAACD,MAAM,GAAG,CAAC,EAAE;QAC3BS,eAAe,CAACR,YAAY,CAAC;MAC/B,CAAC,MAAM;QACLQ,eAAe,CAAC,IAAI,CAAC;MACvB;;MAEA;MACA;IACF;;IAEA;IACA1B,MAAM,CAACC,YAAY,CAACuC,KAAK,CAAC,CAAC;IAC3BtB,YAAY,CAAC0B,OAAO,CAACxB,MAAM,IAAI;MAC7BpB,MAAM,CAACC,YAAY,CAAC4C,GAAG,CAACzB,MAAM,EAAE,IAAI,CAAC;IACvC,CAAC,CAAC;;IAEF;IACAZ,cAAc,CAACU,YAAY,CAAC;EAC9B,CAAC,EAAE,CAACP,YAAY,EAAEH,cAAc,EAAEK,eAAe,EAAEa,eAAe,CAAC,CAAC;;EAEpE;EACA,MAAMoB,YAAY,GAAGhD,WAAW,CAAEsB,MAAc,IAAK;IAAA,IAAA2B,eAAA;IACnD,IAAI,GAAAA,eAAA,GAAC/C,MAAM,CAACgB,MAAM,cAAA+B,eAAA,eAAbA,eAAA,CAAe9B,MAAM,GAAE;;IAE5B;IACA,MAAM+B,SAAS,GAAGrC,YAAY,CAAC4B,GAAG,CAAC,QAAQ,CAAC,IAAI,EAAE;IAClD,MAAMzB,cAAc,GAAGkC,SAAS,GAAGA,SAAS,CAACN,KAAK,CAAC,GAAG,CAAC,CAACtB,MAAM,CAACuB,OAAO,CAAC,GAAG,EAAE;IAC5E,MAAMM,QAAQ,GAAGnC,cAAc,CAACU,QAAQ,CAACJ,MAAM,CAAC;IAEhD,IAAI6B,QAAQ,EAAE;MACZ;MACA,MAAMC,UAAU,GAAGpC,cAAc,CAACM,MAAM,CAAC+B,CAAC,IAAIA,CAAC,KAAK/B,MAAM,CAAC;;MAE3D;MACApB,MAAM,CAACC,YAAY,CAACmD,MAAM,CAAChC,MAAM,CAAC;;MAElC;MACA,IAAI8B,UAAU,CAACjC,MAAM,GAAG,CAAC,EAAE;QACzBS,eAAe,CAACwB,UAAU,CAAC;MAC7B,CAAC,MAAM;QACLxB,eAAe,CAAC,IAAI,CAAC;MACvB;IACF,CAAC,MAAM;MACL;MACA,IAAIjB,YAAY,CAACW,MAAM,CAAC,IAAIX,YAAY,CAACW,MAAM,CAAC,GAAG,CAAC,EAAE;QACpD;QACA,MAAM8B,UAAU,GAAG,CAAC,GAAGpC,cAAc,EAAEM,MAAM,CAAC;QAC9C,MAAMF,YAAY,GAAGL,eAAe,CAACqC,UAAU,CAAC;;QAEhD;QACA,IAAIhC,YAAY,CAACM,QAAQ,CAACJ,MAAM,CAAC,EAAE;UACjC;UACApB,MAAM,CAACC,YAAY,CAAC4C,GAAG,CAACzB,MAAM,EAAE,IAAI,CAAC;;UAErC;UACAM,eAAe,CAACR,YAAY,CAAC;QAC/B;MACF;IACF;EACF,CAAC,EAAE,CAACP,YAAY,EAAEF,YAAY,EAAEI,eAAe,EAAEa,eAAe,CAAC,CAAC;;EAElE;EACA,MAAM2B,YAAY,GAAGvD,WAAW,CAAC,MAAM;IACrC;IACAE,MAAM,CAACC,YAAY,CAACuC,KAAK,CAAC,CAAC;;IAE3B;IACAd,eAAe,CAAC,IAAI,CAAC;EACvB,CAAC,EAAE,CAACA,eAAe,CAAC,CAAC;EAErB,OAAO;IACLoB,YAAY;IACZQ,iBAAiB,EAAExD,WAAW,CAAEsB,MAAc,IAAK;MACjD;MACA,IAAIb,aAAa,CAACiB,QAAQ,CAACJ,MAAM,CAAC,EAAE;QAClC,OAAO,IAAI;MACb;;MAEA;MACA,OAAO,CAACX,YAAY,CAACW,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;IACxC,CAAC,EAAE,CAACb,aAAa,CAAC,CAAC;IACnB8C;EACF,CAAC;AACH,CAAC;;AAED;AAAA3C,EAAA,CArKaJ,aAAa;EAAA,QAKgBP,eAAe;AAAA;AA0KzD,eAAeO,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}