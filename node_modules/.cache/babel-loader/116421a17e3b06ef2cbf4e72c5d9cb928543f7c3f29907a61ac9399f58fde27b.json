{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useCallback } from 'react';\nimport { useSearchParams } from 'react-router-dom';\n// Глобальная Map для хранения состояния фильтров в UI\nif (!window.filterStates) {\n  window.filterStates = new Map();\n}\nexport const useUrlFilters = (activeFilters, onFilterChange, filterCounts) => {\n  _s();\n  var _window$places;\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  // Функция для подсчета базовых счетчиков\n  const calculateBaseCounts = places => {\n    const counts = {};\n    places.forEach(place => {\n      place.attributes.forEach(attr => {\n        counts[attr] = (counts[attr] || 0) + 1;\n      });\n    });\n    return counts;\n  };\n\n  // Функция для проверки фильтров из URL и удаления невалидных\n  const validateUrlFilters = useCallback(() => {\n    if (!window.places || window.places.length === 0) return;\n    const filtersFromUrl = searchParams.get('filter');\n    if (!filtersFromUrl) {\n      // Если нет фильтров в URL, сбрасываем активные фильтры\n      onFilterChange([]);\n      return;\n    }\n    const allFilters = filtersFromUrl.split(',');\n\n    // Проверяем фильтры последовательно\n    const validFilters = [];\n    let currentFilteredPlaces = [...window.places];\n    for (const filter of allFilters) {\n      // Проверяем, останутся ли места после применения этого фильтра\n      const placesWithFilter = currentFilteredPlaces.filter(place => place.attributes.includes(filter));\n      if (placesWithFilter.length > 0) {\n        // Фильтр валидный - добавляем его и обновляем текущий список мест\n        validFilters.push(filter);\n        currentFilteredPlaces = placesWithFilter;\n      }\n    }\n\n    // Если список валидных фильтров изменился, обновляем URL\n    if (validFilters.length !== allFilters.length) {\n      if (validFilters.length === 0) {\n        // Если не осталось валидных фильтров, удаляем параметр filter из URL\n        const path = window.location.pathname;\n        window.history.pushState({}, '', path);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      } else {\n        // Обновляем URL только с валидными фильтрами\n        const path = window.location.pathname;\n        const newURL = `${path}?filter=${validFilters.join(',')}`;\n        window.history.pushState({}, '', newURL);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      }\n    }\n\n    // Обновляем активные фильтры в UI\n    onFilterChange(validFilters);\n  }, [searchParams, onFilterChange, setSearchParams]);\n\n  // Проверяем фильтры при изменении URL или загрузке данных\n  useEffect(() => {\n    validateUrlFilters();\n  }, [searchParams, validateUrlFilters, (_window$places = window.places) === null || _window$places === void 0 ? void 0 : _window$places.length]);\n\n  // Проверка доступности фильтра\n  const isFilterAvailable = useCallback(filter => {\n    if (!window.places || window.places.length === 0) return false;\n\n    // Если фильтр уже активен, он всегда доступен\n    if (activeFilters.includes(filter)) return true;\n\n    // Получаем текущий отфильтрованный список мест\n    let currentPlaces = [...window.places];\n\n    // Применяем все активные фильтры последовательно\n    for (const activeFilter of activeFilters) {\n      currentPlaces = currentPlaces.filter(place => place.attributes.includes(activeFilter));\n    }\n\n    // Проверяем, останутся ли места после применения нового фильтра\n    const placesWithNewFilter = currentPlaces.filter(place => place.attributes.includes(filter));\n    return placesWithNewFilter.length > 0;\n  }, [activeFilters]);\n\n  // Переключение фильтра\n  const toggleFilter = useCallback(filter => {\n    var _searchParams$get;\n    if (!window.places || window.places.length === 0) return;\n\n    // Получаем текущий список фильтров из URL\n    const currentFilters = ((_searchParams$get = searchParams.get('filter')) === null || _searchParams$get === void 0 ? void 0 : _searchParams$get.split(',').filter(Boolean)) || [];\n    if (currentFilters.includes(filter)) {\n      // Если фильтр уже активен, удаляем его\n      const newFilters = currentFilters.filter(f => f !== filter);\n      if (newFilters.length === 0) {\n        // Если не осталось фильтров, удаляем параметр filter из URL\n        const path = window.location.pathname;\n        window.history.pushState({}, '', path);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      } else {\n        // Обновляем URL с оставшимися фильтрами\n        const path = window.location.pathname;\n        const newURL = `${path}?filter=${newFilters.join(',')}`;\n        window.history.pushState({}, '', newURL);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      }\n    } else {\n      // Если фильтр неактивен, проверяем, можно ли его добавить\n      if (isFilterAvailable(filter)) {\n        // Добавляем фильтр к текущим\n        const newFilters = [...currentFilters, filter];\n        const path = window.location.pathname;\n        const newURL = `${path}?filter=${newFilters.join(',')}`;\n        window.history.pushState({}, '', newURL);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      }\n    }\n  }, [searchParams, isFilterAvailable]);\n\n  // Сброс всех фильтров\n  const resetFilters = useCallback(() => {\n    const path = window.location.pathname;\n    window.history.pushState({}, '', path);\n    // Вызываем событие для React Router\n    window.dispatchEvent(new Event('popstate'));\n  }, []);\n  return {\n    toggleFilter,\n    isFilterAvailable,\n    resetFilters\n  };\n};\n\n// Добавляем типы для window\n_s(useUrlFilters, \"aCqtuEvVgJzH9l4vNQhg5/hhTF0=\", false, function () {\n  return [useSearchParams];\n});\nexport default useUrlFilters;","map":{"version":3,"names":["useEffect","useCallback","useSearchParams","window","filterStates","Map","useUrlFilters","activeFilters","onFilterChange","filterCounts","_s","_window$places","searchParams","setSearchParams","calculateBaseCounts","places","counts","forEach","place","attributes","attr","validateUrlFilters","length","filtersFromUrl","get","allFilters","split","validFilters","currentFilteredPlaces","filter","placesWithFilter","includes","push","path","location","pathname","history","pushState","dispatchEvent","Event","newURL","join","isFilterAvailable","currentPlaces","activeFilter","placesWithNewFilter","toggleFilter","_searchParams$get","currentFilters","Boolean","newFilters","f","resetFilters"],"sources":["/Users/borvel/Documents/GitHub/places-app/src/hooks/useUrlFilters.ts"],"sourcesContent":["import { useEffect, useCallback } from 'react';\nimport { useSearchParams } from 'react-router-dom';\nimport { Place } from '../types/places';\n\n// Глобальная Map для хранения состояния фильтров в UI\nif (!window.filterStates) {\n  window.filterStates = new Map<string, boolean>();\n}\n\nexport const useUrlFilters = (\n  activeFilters: string[],\n  onFilterChange: (filters: string[]) => void,\n  filterCounts: Record<string, number>\n) => {\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  // Функция для подсчета базовых счетчиков\n  const calculateBaseCounts = (places: Place[]) => {\n    const counts: Record<string, number> = {};\n    \n    places.forEach(place => {\n      place.attributes.forEach(attr => {\n        counts[attr] = (counts[attr] || 0) + 1;\n      });\n    });\n    \n    return counts;\n  };\n\n  // Функция для проверки фильтров из URL и удаления невалидных\n  const validateUrlFilters = useCallback(() => {\n    if (!window.places || window.places.length === 0) return;\n\n    const filtersFromUrl = searchParams.get('filter');\n    \n    if (!filtersFromUrl) {\n      // Если нет фильтров в URL, сбрасываем активные фильтры\n      onFilterChange([]);\n      return;\n    }\n\n    const allFilters = filtersFromUrl.split(',');\n    \n    // Проверяем фильтры последовательно\n    const validFilters: string[] = [];\n    let currentFilteredPlaces = [...window.places];\n\n    for (const filter of allFilters) {\n      // Проверяем, останутся ли места после применения этого фильтра\n      const placesWithFilter = currentFilteredPlaces.filter(place => \n        place.attributes.includes(filter)\n      );\n\n      if (placesWithFilter.length > 0) {\n        // Фильтр валидный - добавляем его и обновляем текущий список мест\n        validFilters.push(filter);\n        currentFilteredPlaces = placesWithFilter;\n      }\n    }\n\n    // Если список валидных фильтров изменился, обновляем URL\n    if (validFilters.length !== allFilters.length) {\n      if (validFilters.length === 0) {\n        // Если не осталось валидных фильтров, удаляем параметр filter из URL\n        const path = window.location.pathname;\n        window.history.pushState({}, '', path);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      } else {\n        // Обновляем URL только с валидными фильтрами\n        const path = window.location.pathname;\n        const newURL = `${path}?filter=${validFilters.join(',')}`;\n        window.history.pushState({}, '', newURL);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      }\n    }\n\n    // Обновляем активные фильтры в UI\n    onFilterChange(validFilters);\n  }, [searchParams, onFilterChange, setSearchParams]);\n\n  // Проверяем фильтры при изменении URL или загрузке данных\n  useEffect(() => {\n    validateUrlFilters();\n  }, [searchParams, validateUrlFilters, window.places?.length]);\n\n  // Проверка доступности фильтра\n  const isFilterAvailable = useCallback((filter: string) => {\n    if (!window.places || window.places.length === 0) return false;\n\n    // Если фильтр уже активен, он всегда доступен\n    if (activeFilters.includes(filter)) return true;\n\n    // Получаем текущий отфильтрованный список мест\n    let currentPlaces = [...window.places];\n    \n    // Применяем все активные фильтры последовательно\n    for (const activeFilter of activeFilters) {\n      currentPlaces = currentPlaces.filter(place => \n        place.attributes.includes(activeFilter)\n      );\n    }\n\n    // Проверяем, останутся ли места после применения нового фильтра\n    const placesWithNewFilter = currentPlaces.filter(place => \n      place.attributes.includes(filter)\n    );\n\n    return placesWithNewFilter.length > 0;\n  }, [activeFilters]);\n\n  // Переключение фильтра\n  const toggleFilter = useCallback((filter: string) => {\n    if (!window.places || window.places.length === 0) return;\n\n    // Получаем текущий список фильтров из URL\n    const currentFilters = searchParams.get('filter')?.split(',').filter(Boolean) || [];\n    \n    if (currentFilters.includes(filter)) {\n      // Если фильтр уже активен, удаляем его\n      const newFilters = currentFilters.filter(f => f !== filter);\n      \n      if (newFilters.length === 0) {\n        // Если не осталось фильтров, удаляем параметр filter из URL\n        const path = window.location.pathname;\n        window.history.pushState({}, '', path);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      } else {\n        // Обновляем URL с оставшимися фильтрами\n        const path = window.location.pathname;\n        const newURL = `${path}?filter=${newFilters.join(',')}`;\n        window.history.pushState({}, '', newURL);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      }\n    } else {\n      // Если фильтр неактивен, проверяем, можно ли его добавить\n      if (isFilterAvailable(filter)) {\n        // Добавляем фильтр к текущим\n        const newFilters = [...currentFilters, filter];\n        const path = window.location.pathname;\n        const newURL = `${path}?filter=${newFilters.join(',')}`;\n        window.history.pushState({}, '', newURL);\n        // Вызываем событие для React Router\n        window.dispatchEvent(new Event('popstate'));\n      }\n    }\n  }, [searchParams, isFilterAvailable]);\n\n  // Сброс всех фильтров\n  const resetFilters = useCallback(() => {\n    const path = window.location.pathname;\n    window.history.pushState({}, '', path);\n    // Вызываем событие для React Router\n    window.dispatchEvent(new Event('popstate'));\n  }, []);\n\n  return {\n    toggleFilter,\n    isFilterAvailable,\n    resetFilters\n  };\n};\n\n// Добавляем типы для window\ndeclare global {\n  interface Window {\n    filterStates: Map<string, boolean>;\n    places: Place[];\n  }\n}\n\nexport default useUrlFilters; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}